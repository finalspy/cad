<!-- Sommaire -->
<section>
  <h2>ğŸ—‚ï¸ Sommaire</h2>
  <ul>
    <li>ğŸ“– PartieÂ 1Â : ThÃ©orie DDD
      <ul>
        <li>ğŸ¯ Pourquoi DDDÂ ?</li>
        <li>ğŸ§­ Concepts stratÃ©giques</li>
        <li>ğŸ› ï¸ Concepts tactiques</li>
      </ul>
    </li>
    <li>ğŸš€ PartieÂ 2Â : PratiqueÂ VibeReveal
      <ul>
        <li>ğŸ“‹ Cartographie du monolithe</li>
        <li>ğŸ—ï¸ Extraction du Domain Model</li>
        <li>ğŸ”§ Refactoring PresentationService</li>
        <li>ğŸ’¾ Repositories</li>
        <li>ğŸ›ï¸ Application Services</li>
        <li>ğŸ”„ Event Bus</li>
      </ul>
    </li>
    <li>âœ… Conclusion</li>
    <li>ğŸ“š Ressources</li>
    <li>â“ Quiz</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>PrÃ©sentation du plan : thÃ©orie d'abord, puis application sur VibeReveal.</li>
      <li>Chaque partie comporte plusieurs Ã©tapes clairement marquÃ©es.</li>
    </ul>
  </aside>
</section>

<!-- Transition vers Partie 1 -->
<section>
  <h2>ğŸ“– PartieÂ 1Â : ThÃ©orie DDD</h2>
  <p>Comprendre les concepts clÃ©s pour modÃ©liser un domaine riche.</p>
  <aside class="notes">
    <ul>
      <li>ObjectifÂ : donner un langage commun et des rÃ¨gles d'organisation au code.</li>
    </ul>
  </aside>
</section>

<!-- Pourquoi DDD -->
<section>
  <h2>ğŸ¯ Pourquoi DDDÂ ?</h2>
  <ul>
    <li>Aligner le code sur le cÅ“ur mÃ©tier pour rester pertinent.</li>
    <li>RÃ©duire les malentendus avec un vocabulaire unique.</li>
    <li>Faciliter la maintenance et lâ€™Ã©volution du logiciel.</li>
    <li>GÃ©rer la complexitÃ© dans les systÃ¨mes distribuÃ©s.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Sans DDD, chaque Ã©quipe peut appeler la mÃªme chose diffÃ©remment.</li>
      <li>Expliquer : 40â€¯% des retards proviennent de ce manque dâ€™alignement.</li>
    </ul>
  </aside>
</section>

<!-- Ubiquitous Language -->
<section>
  <h2>ğŸ§­ Ubiquitous Language</h2>
  <ul>
    <li>CrÃ©er un dictionnaire commun de termes mÃ©tier (exÂ : Presentation, Slide).</li>
    <li>Utiliser ces termes partoutÂ : code, docs, discussions.</li>
    <li>Ã‰viter tout synonyme pour un mÃªme concept.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>ExempleÂ : Â« Slide Â» dÃ©signe toujours une diapositive, jamais un composant UI.</li>
      <li>Maintenir ce glossaire Ã  jour en revue de code.</li>
    </ul>
  </aside>
</section>

<!-- Bounded Context -->
<section>
  <h2>ğŸ”’ Bounded Context</h2>
  <ul>
    <li>DÃ©limiter des zones oÃ¹ un modÃ¨le est cohÃ©rent.</li>
    <li>Chaque contexte a son propre langage et ses entitÃ©s.</li>
    <li>Communiquer entre contextes via contrats (API, events, adapters).</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>ExemplesÂ : EditingContext pour la crÃ©ation, PublishingContext pour lâ€™export.</li>
      <li>PrÃ©venir le couplage fort avec un Anti-Corruption Layer.</li>
    </ul>
  </aside>
</section>

<!-- Context Mapping -->
<section>
  <h2>ğŸ—ºï¸ Context Mapping</h2>
  <div class="mermaid">
    graph LR
      EditingCtx["EditingContext"]
      PublishingCtx["PublishingContext"]
      Auth["AuthService"]
      Analytics["AnalyticsService"]
      EditingCtx -->|"valide user"| Auth
      EditingCtx -->|"crÃ©Ã©"| PublishingCtx
      PublishingCtx -->|"notifie"| Analytics
  </div>
  <aside class="notes">
    <ul>
      <li>Montrer les flux dâ€™informations et les patterns de relation.</li>
      <li>Expliquer lâ€™utilitÃ© dâ€™un contexte partagÃ© ou dâ€™un ACL.</li>
    </ul>
  </aside>
</section>

<!-- Transition vers Partie 1 tactique -->
<section>
  <h2>ğŸ› ï¸ PartieÂ 1Â : Concepts Tactiques</h2>
  <p>Les rÃ¨gles de construction dans le code.</p>
  <aside class="notes">
    <ul>
      <li>Les building blocks DDD appliquÃ©s en TypeScript.</li>
    </ul>
  </aside>
</section>

<!-- Entity -->
<section>
  <h2>ğŸ·ï¸ Entity</h2>
  <ul>
    <li>Objet avec identitÃ© unique (ID).</li>
    <li>Cicatrice : peut Ã©voluer, mais reste toujours le mÃªme.</li>
    <li>Cycle de vie : crÃ©ationÂ â†’Â modificationÂ â†’Â suppression.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>ExÂ : Slide a toujours le mÃªme ID mÃªme si son contenu change.</li>
    </ul>
  </aside>
</section>

<!-- Value Object -->
<section>
  <h2>ğŸ¨ Value Object</h2>
  <ul>
    <li>Immuable : pas de modification, on crÃ©e de nouvelles instances.</li>
    <li>Ã‰galitÃ© par valeur : mÃªmes attributsÂ â†’Â mÃ©me objet conceptuel.</li>
    <li>Pas dâ€™IDÂ ; dÃ©finit un concept (exÂ : SlideContent).</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>SlideContent contient texte et imageUrl, et ne change jamais.</li>
    </ul>
  </aside>
</section>

<!-- Example Entity vs VO -->
<section>
  <h2>ğŸ“¦ ExempleÂ : Slide & SlideContent</h2>
  <pre><code class="language-ts">class SlideContent { constructor(text: string) { /* ... */ } }
class Slide { constructor(id: string, content: SlideContent) { /* ... */ } }
</code></pre>
  <aside class="notes">
    <ul>
      <li>SlideContent partagÃ© entre plusieurs Slides.</li>
      <li>Chaque Slide garde son ID unique.</li>
    </ul>
  </aside>
</section>

<!-- Aggregate -->
<section>
  <h2>ğŸŒ³ Aggregate</h2>
  <ul>
    <li>Groupe cohÃ©rent dâ€™entities et de VOs.</li>
    <li>Aggregate Root (exÂ : Presentation) contrÃ´le lâ€™accÃ¨s.</li>
    <li>Transactional boundaryÂ : tout ou rien.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>PrÃ©sentation agit comme la seule porte dâ€™entrÃ©e pour ses Slides.</li>
    </ul>
  </aside>
</section>

<!-- Example Aggregate -->
<section>
  <h2>ğŸ“‹ ExempleÂ : Presentation</h2>
  <pre><code class="language-ts">class Presentation { /* ... */ }
const pres = new Presentation('p1');
pres.addSlide(new SlideContent('Hi')); 
</code></pre>
  <aside class="notes">
    <ul>
      <li>Chaque ajout de slide doit passer par la racine dâ€™agrÃ©gat.</li>
    </ul>
  </aside>
</section>

<!-- Domain Service -->
<section>
  <h2>âš™ï¸ Domain Service</h2>
  <ul>
    <li>Logique mÃ©tier transcendant plusieurs agrÃ©gats.</li>
    <li>ExÂ : calcul de statistiques sur plusieurs Presentations.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Ne stocke pas de donnÃ©es, nâ€™appartient Ã  aucune entitÃ©.</li>
    </ul>
  </aside>
</section>

<!-- Factory -->
<section>
  <h2>ğŸ­ Factory</h2>
  <ul>
    <li>Produit des agrÃ©gats en garantissant des invariants.</li>
    <li>ExÂ : crÃ©ation dâ€™une Presentation avec une slide dâ€™accueil.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Placez la logique de construction complexe ici.</li>
    </ul>
  </aside>
</section>

<!-- Repository -->
<section>
  <h2>ğŸ’¾ Repository</h2>
  <ul>
    <li>Abstraction de la persistence des agrÃ©gats.</li>
    <li>ExÂ : interface pour MongoDB ou In-Memory.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Ne contient pas de logique mÃ©tier, juste CRUD et requÃªtes simples.</li>
    </ul>
  </aside>
</section>

<!-- Domain Event -->
<section data-transition="fade">
  <h3>ğŸ”” Domain Event</h3>
  <ul>
    <li>Message immuable signalant un changement mÃ©tier.</li>
    <li>DÃ©clencheur dâ€™actions asynchrones.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>ExÂ : <code>SlideAddedEvent</code> pour lancer lâ€™export Reveal.js.</li>
    </ul>
  </aside>
</section>

<!-- Mermaid sequence diagram -->
<section data-transition="fade">
  <h2>ğŸ”„ SÃ©quence : Export Reveal.js</h2>
  <div class="mermaid">
    sequenceDiagram
      participant U as User
      participant C as Controller
      participant A as AppService
      participant D as DomainService
      participant R as Repository
      participant E as EventBus
      participant P as PublishingCtx
      U->>C: POST /export
      C->>A: createExport(dto)
      A->>D: exportPresentation(id)
      D->>R: findById(id)
      R-->>D: Presentation
      D->>E: publish(SlideAddedEvent)
      E->>P: handleExport
      P->>P: generateRevealBundle
      P-->>U: return bundle
  </div>
  <aside class="notes">
    <ul>
      <li>Montrer la chaÃ®ne du HTTP jusquâ€™au bundle Reveal.js.</li>
      <li>Mettre en Ã©vidence la sÃ©paration des responsabilitÃ©s Ã  chaque Ã©tape.</li>
    </ul>
  </aside>
</section>

<!-- Transition vers Partie 2 -->
<section>
  <h2>ğŸš€ PartieÂ 2Â : Pratique VibeReveal</h2>
  <p>Refactoring pas-Ã -pas de votre monolithe vers DDD.</p>
  <aside class="notes">
    <ul>
      <li>Nous allons partir de votre code existant et le restructurer.</li>
    </ul>
  </aside>
</section>

<!-- PARTIE 2 Pratique -->
<section>
  <h2>ğŸ“‹ Cartographie du monolithe actuel</h2>
  <pre><code>// Structure du monolithe VibeReveal existant
src/
â”œâ”€ controllers/
â”œâ”€ services/
â”‚  â”” presentationService.js
â”œâ”€ routes/
â”œâ”€ models/
â”œâ”€ public/
â”‚  â”œ js/
â”‚  â”” css/
â””â”€ utils/
</code></pre>
  <aside class="notes">
    <ul>
      <li>Identifier les modules actuels et leur responsabilitÃ©.</li>
      <li>RepÃ©rer les couches mÃ©langeant logique mÃ©tier, API et persistence.</li>
    </ul>
  </aside>
</section>


<section>
  <h2>ğŸ—ï¸ Extraction du Domain Model</h2>
  <pre><code>// CrÃ©er un dossier domain/ avec :
// domain/entities/Presentation.ts
// domain/entities/Slide.ts
// domain/valueObjects/SlideContent.ts
</code></pre>
  <aside class="notes">
    <ul>
      <li>Isoler les classes mÃ©tier du reste du code.</li>
      <li>Conserver uniquement les attributs et rÃ¨gles mÃ©tier.</li>
    </ul>
  </aside>
</section>
<section>
  <h2>ğŸ”§ Refactoring de PresentationService</h2>
  <pre><code>// Avant: presentationService.js
function createPresentation(data) { /* mÃ©lange validation, persistence */ }

// AprÃ¨s: domain/services/PresentationService.ts
class PresentationService {
  constructor(
    private readonly repo: PresentationRepository
  ) {}
  create(data: CreatePresentationDto) {
    const pres = PresentationFactory.create(data.id, data.title);
    return this.repo.save(pres);
  }
}
</code></pre>
  <aside class="notes">
    <ul>
      <li>SÃ©parer la validation mÃ©tier, la crÃ©ation de lâ€™agrÃ©gat et la persistence.</li>
      <li>Utiliser PresentationFactory pour construire lâ€™entitÃ©.</li>
    </ul>
  </aside>
</section>
<section>
  <h2>ğŸ’¾ Mise en place de Repository</h2>
  <pre><code>// infra/repositories/MongoPresentationRepository.ts
class MongoPresentationRepository implements PresentationRepository {
  async save(pres: Presentation): Promise<void> {
    await mongoClient.collection('presentations')
      .insertOne(pres);
  }
  async findById(id: string) {
    const doc = await mongoClient
      .collection('presentations')
      .findOne({ id });
    return doc ? Presentation.from(doc) : null;
  }
}
</code></pre>
  <aside class="notes">
    <ul>
      <li>Encapsuler lâ€™accÃ¨s Ã  MongoDB derriÃ¨re une interface.</li>
      <li>PrÃ©server le Domain Model indÃ©pendant de la persistence.</li>
    </ul>
  </aside>
</section>
<section>
  <h2>ğŸ›ï¸ Conversion des Controllers en Application Services</h2>
  <pre><code>// routes/presentationRoutes.ts
router.post('/presentations', async (req, res) => {
  const result = await presentationService.create(req.body);
  res.json(result);
});

// application/PresentationAppService.ts
class PresentationAppService {
  constructor(private svc: PresentationService) {}
  async createPresentation(dto: any) {
    return this.svc.create(dto);
  }
}
</code></pre>
  <aside class="notes">
    <ul>
      <li>Utiliser un adapter pour convertir DTO HTTP en DTO mÃ©tier.</li>
      <li>Gardez les controllers fins (thin controllers).</li>
    </ul>
  </aside>
</section>
<section>
  <h2>ğŸ”„ Publication dâ€™Ã©vÃ©nements et intÃ©gration Event Bus</h2>
  <pre><code>// domain/events/PresentationCreated.ts
class PresentationCreated {
  constructor(
    public readonly id: string,
    public readonly timestamp = new Date()
  ){}
}

// AprÃ¨s save dans PresentationService:
this.repo.save(pres);
eventBus.publish(new PresentationCreated(pres.id));
</code></pre>
  <aside class="notes">
    <ul>
      <li>Publier un event Ã  chaque changement critique.</li>
      <li>DÃ©charger lâ€™export Reveal.js dans un consumer asynchrone.</li>
    </ul>
  </aside>
</section>

<!-- Erreurs courantes Ã  Ã©viter -->
<section>
  <h2>âŒ Erreurs courantes Ã  Ã©viter</h2>
  <ul>
    <li>Anemic Domain Model : logique mÃ©tier dans les services, pas dans les entitÃ©s.</li>
    <li>AgrÃ©gats trop gros (> 5-7 objets) : complexitÃ© et verrous.</li>
    <li>Transactions distribuÃ©es entre agrÃ©gats : risque de deadlocks.</li>
    <li>RÃ©fÃ©rences directes entre bounded contexts : couplage fort.</li>
    <li>Repository qui fuit la logique mÃ©tier : mÃ©thodes trop spÃ©cifiques.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Lâ€™Anemic Domain Model conduit Ã  du code procÃ©dural, perdant lâ€™encapsulation.</li>
      <li>AgrÃ©gats trop volumineux dÃ©gradent performances (+40-60%) et maintenabilitÃ©.</li>
      <li>PrivilÃ©gier la cohÃ©rence Ã©ventuelle via Domain Events plutÃ´t que transactions cross-agrÃ©gat.</li>
      <li>Communiquer entre contexts via Ã©vÃ©nements ou ACL, jamais par rÃ©fÃ©rences directes.</li>
      <li>Utiliser le pattern Specification plutÃ´t que des mÃ©thodes reposant sur la logique mÃ©tier.</li>
    </ul>
  </aside>
</section>

<!-- Bonnes pratiques -->
<section>
  <h2>âœ… Bonnes pratiques</h2>
  <ul>
    <li>Commencer petit : un seul bounded context Ã  la fois.</li>
    <li>ModÃ©lisation stratÃ©gique avant dâ€™Ã©crire du code (Event Storming, Context Mapping).</li>
    <li>Tester le domaine en prioritÃ© : tests unitaires sur agrÃ©gats et services.</li>
    <li>Maintenir le langage omniprÃ©sent : vÃ©rifier en revue de code.</li>
    <li>Ã‰viter la sur-ingÃ©nierie : DDD pour domaines complexes, pas CRUD simples.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Investir 20% du temps en ateliers de modÃ©lisation avant dÃ©veloppement.</li>
      <li>Visez 90%+ de couverture de tests sur le domaine.</li>
      <li>Validez le vocabulaire en code review pour Ã©viter la dette technique.</li>
      <li>Appliquer DDD progressivement, en pilotant un contexte critique en premier.</li>
    </ul>
  </aside>
</section>

<section>
  <h2>âœ… Conclusion</h2>
  <ul>
    <li>Le DDD amÃ©liore la qualitÃ© et la maintenabilitÃ© de VibeReveal.</li>
    <li>Patrons avancÃ©sÂ : CQRS, Event Sourcing, Hexagonal Architecture.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Partager les rÃ©fÃ©rences pour approfondir chaque pattern.</li>
      <li>Encourager les Ã©changes au sein de la formation.</li>
    </ul>
  </aside>
</section>

<section>
  <h2>ğŸ“š Ressources</h2>
  <ul>
    <li>Domain-Driven DesignÂ : livre par Eric Evans</li>
    <li>Implementing Domain-Driven DesignÂ : Vaughn Vernon</li>
    <li><a href="https://www.domainlanguage.com/ddd/">domainlanguage.com/ddd</a></li>
    <li><a href="https://martinfowler.com/bliki/BoundedContext.html">martinfowler.com - Bounded Context</a></li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Proposer des lectures pour approfondir chaque concept DDD.</li>
      <li>Inviter Ã  rejoindre la communautÃ© DDD pour Ã©changer des retours.</li>
    </ul>
  </aside>
</section>

<section>
  <h2>â“ Quiz Interactif</h2>
  <ul>
    <li>1. Qu'est-ce qu'un Value Object ?
      <ul>
        <li>A) Un objet avec une identitÃ© unique</li>
        <li>B) Un objet immuable dÃ©fini par ses attributs</li>
        <li>C) Un service applicatif</li>
        <li>D) Un Ã©vÃ©nement mÃ©tier</li>
      </ul>
    </li>
    <li>2. Quel est le rÃ´le de lâ€™Aggregate Root ?
      <ul>
        <li>A) ContrÃ´ler la consistance de lâ€™agrÃ©gat</li>
        <li>B) Publier des Ã©vÃ©nements</li>
        <li>C) GÃ©rer directement la persistance</li>
        <li>D) DÃ©finir lâ€™interface utilisateur</li>
      </ul>
    </li>
    <li>3. Ã€ quoi sert un Domain Service ?
      <ul>
        <li>A) Stocker les donnÃ©es</li>
        <li>B) Orchestrer la logique mÃ©tier sans appartenir Ã  une entitÃ©</li>
        <li>C) Convertir les DTO HTTP</li>
        <li>D) GÃ©nÃ©rer des vues</li>
      </ul>
    </li>
    <li>4. Qu'est-ce qu'un Repository ?
      <ul>
        <li>A) Un objet mÃ©tier</li>
        <li>B) Une interface de persistance pour les agrÃ©gats</li>
        <li>C) Un service d'export Reveal.js</li>
        <li>D) Une factory</li>
      </ul>
    </li>
    <li>5. Quel pattern protÃ¨ge un contexte dâ€™influence externe ?
      <ul>
        <li>A) Shared Kernel</li>
        <li>B) Anti-Corruption Layer</li>
        <li>C) Conformist</li>
        <li>D) Partnership</li>
      </ul>
    </li>
    <li>6. Qu'est-ce qu'un Domain Event ?
      <ul>
        <li>A) Un objet immuable signalant un changement mÃ©tier</li>
        <li>B) Une entitÃ© avec identitÃ©</li>
        <li>C) Un Value Object</li>
        <li>D) Un service mÃ©tier</li>
      </ul>
    </li>
    <li>7. Pourquoi utiliser un Ubiquitous Language ?
      <ul>
        <li>A) Pour rÃ©duire la duplication de code</li>
        <li>B) Pour aligner la communication entre mÃ©tiers et technique</li>
        <li>C) Pour cacher la logique mÃ©tier</li>
        <li>D) Pour amÃ©liorer la performance</li>
      </ul>
    </li>
    <li>8. Qu'est-ce qu'une Context Map ?
      <ul>
        <li>A) Liste de tous les modules</li>
        <li>B) Diagramme des relations entre bounded contexts</li>
        <li>C) Graphique de performance</li>
        <li>D) Catalogue de services</li>
      </ul>
    </li>
    <li>9. Quelle est la Transactional Boundary ?
      <ul>
        <li>A) La limite dâ€™un service HTTP</li>
        <li>B) La limite au sein de lâ€™agrÃ©gat oÃ¹ la cohÃ©rence est garantie</li>
        <li>C) Un service de domaine</li>
        <li>D) Un Ã©vÃ©nement mÃ©tier</li>
      </ul>
    </li>
    <li>10. Quel pattern permet lâ€™autonomie des Ã©quipes en limitant les dÃ©pendances ?
      <ul>
        <li>A) Conformist</li>
        <li>B) Customerâ€“Supplier</li>
        <li>C) Anti-Corruption Layer</li>
        <li>D) Shared Kernel</li>
      </ul>
    </li>
  </ul>
  <p><strong>RÃ©ponses correctes :</strong> 1:B, 2:A, 3:B, 4:B, 5:B, 6:A, 7:B, 8:B, 9:B, 10:B</p>
  <p><strong>Politique de notation :</strong> +1 point pour chaque rÃ©ponse correcte, -0,25 point pour chaque mauvaise rÃ©ponse, note minimale 0, note maximale 10.</p>
  <aside class="notes">
    <ul>
      <li>Proposez dâ€™utiliser Mentimeter pour collecter les rÃ©ponses en temps rÃ©el.</li>
      <li>Ou intÃ©grez directement un plugin quiz dans Reveal.js (par exemple Reveal Quiz Plugin).</li>
    </ul>
  </aside>
</section>

<section>
  <h2>ğŸ“ˆ Avantages & InconvÃ©nients de lâ€™Architecture DistribuÃ©e</h2>
  <ul>
    <li><strong>Avantages :</strong>
      <ul>
        <li>ScalabilitÃ© indÃ©pendante des services.</li>
        <li>RÃ©silience accrue grÃ¢ce Ã  la dÃ©centralisation.</li>
        <li>Ã‰volution autonome des bounded contexts.</li>
      </ul>
    </li>
    <li><strong>InconvÃ©nients :</strong>
      <ul>
        <li>ComplexitÃ© de gestion des transactions distribuÃ©es.</li>
        <li>Latence et surcharge rÃ©seau plus importantes.</li>
        <li>ComplexitÃ© accrue du monitoring et du debugging.</li>
      </ul>
    </li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Souligner lâ€™impact sur lâ€™organisation : nÃ©cessite des compÃ©tences DevOps et surveillance.</li>
      <li>Montrer que la modÃ©lisation DDD facilite le dÃ©coupage distribuÃ©.</li>
    </ul>
  </aside>
</section>

<section>
  <h2>ğŸš€ Ã‰tapes suivantes</h2>
  <ul>
    <li>1ï¸âƒ£ ImplÃ©menter CQRS pour sÃ©parer lecture et Ã©criture.</li>
    <li>2ï¸âƒ£ Introduire lâ€™Event Sourcing pour historiser les changements.</li>
    <li>3ï¸âƒ£ Adopter lâ€™architecture hexagonale (ports & adapters).</li>
    <li>4ï¸âƒ£ Mettre en place des tests dâ€™intÃ©gration et des contrats.</li>
    <li>5ï¸âƒ£ Automatiser le dÃ©ploiement continu pour chaque contexte.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Proposer un atelier de 2 h sur CQRS et Event Sourcing.</li>
      <li>Planifier un pilote sur un bounded context de VibeReveal.</li>
    </ul>
  </aside>
</section>
