<!-- Slide 0: Titre -->
<section data-background-image="/public/images/titre_distribuees.jpg"
         data-background-size="cover"
         data-background-opacity="0.6">
  <h2 style="font-size:2.7em; color:#fff; text-shadow:1px 1px 10px #333;">
    Patterns de Communication & Architecture Avanc√©e<br>
    <span style="font-size:0.65em; font-weight:normal;">API Gateway, Synchrone, Asynchrone, Event Sourcing, CQRS</span>
  </h2>
  <aside class="notes">
    <ul>
      <li>Bienvenue, introduction du th√®me principal du module.</li>
      <li>Objectif : comprendre les patterns essentiels des applications distribu√©es modernes.</li>
      <li>Annonce du fil rouge : API Gateway, communications, Event Sourcing, CQRS.</li>
    </ul>
  </aside>
</section>
<section>
  <h2>Sommaire</h2>
  <ul>
    <li>üéØ <strong>Introduction</strong> : d√©finitions et enjeux</li>
    <li>üö™ <strong>API Gateway</strong> : r√¥le, cas d'usage, bonnes pratiques</li>
    <li>üîó <strong>Communication synchrone</strong> : principes, avantages/inconv√©nients</li>
    <li>üì¨ <strong>Communication asynchrone</strong> : patterns, brokers, r√©silience</li>
    <li>üìù <strong>Event Sourcing</strong> : concept, cas d'usage, d√©fis</li>
    <li>üîÑ <strong>CQRS</strong> : principes, exemples, limites</li>
    <li>‚ùì <strong>Quiz & questions</strong></li>
    <li>üìö <strong>Sources & liens utiles</strong></li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Tour rapide du plan : chaque partie apporte une brique de compr√©hension sur les architectures distribu√©es.</li>
      <li>Annonce de la pr√©sence de quiz et de sources √† la fin.</li>
    </ul>
  </aside>
</section>
<!-- Slide 1: API Gateway - D√©finition -->
<section>
  <h2>API Gateway</h2>
  <ul>
    <li>Point d'entr√©e unique pour des APIs REST ou WebSocket</li>
    <li>D√©couple les clients des services backend</li>
    <li>G√®re routage, authentification, limitation de d√©bit, monitoring</li>
  </ul>
  <div class="mermaid">
    flowchart LR
      Client[Client]
      APIGW[API Gateway]
      Service1[Microservice 1]
      Service2[Microservice 2]
      Service3[Microservice 3]
      Client --> APIGW
      APIGW --> Service1
      APIGW --> Service2
      APIGW --> Service3
  </div>
  <aside class="notes">
    <ul>
      <li>Un <b>API Gateway</b> agit comme la porte d'entr√©e unique (¬´ front door ¬ª) centralisant le trafic entrant, la s√©curit√© et la surveillance de vos microservices.</li>
      <li>Il g√®re le routage, l'authentification, le monitoring, la <b>limitation de d√©bit</b> (<i>rate limiting</i>) et la transformation de requ√™tes/r√©ponses.</li>
      <li>D√©couplage : le client ne conna√Æt pas les d√©tails des services backend ni leurs √©volutions.</li>
      <li>Analogie : c'est le portier d'un immeuble, qui filtre les visiteurs et les oriente vers les bons √©tages.</li>
      <li>Outils : <a href="https://konghq.com/" target="_blank">Kong</a> (open source), <a href="https://tyk.io/" target="_blank">Tyk</a>, <a href="https://aws.amazon.com/api-gateway/" target="_blank">AWS API Gateway</a>.</li>
      <li>√Ä ne pas faire : ne surchargez pas votre gateway avec toute la logique m√©tier ‚Äî restez sur l'orchestration et la s√©curit√©.</li>
    </ul>
  </aside>
</section>

<!-- Slide 2: API Gateway - Cas d'usage et exemples -->
<section>
  <h3>Cas d'usage et exemples</h3>
  <ul>
    <li>Exposition d'un backend serverless (Lambda, Azure Functions)</li>
    <li>Aggregation de plusieurs services en un seul endpoint</li>
    <li>Migration de microservices en versions g√©r√©es</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Exposer une fonction <b>serverless</b> (AWS Lambda, Azure Function, GCP Function) comme API HTTP facilement.</li>
      <li>Agr√©gation : exemple d'un endpoint ‚ÄúMon Profil‚Äù qui compose les infos utilisateur, commandes et notifications via plusieurs microservices.</li>
      <li>Gestion des versions : le Gateway permet de migrer vers de nouvelles versions sans perturber les clients.</li>
      <li>Exp√©rience terrain : les API Gateway sont utilis√©s dans toutes les architectures modernes √† grande √©chelle (e-commerce, SaaS, jeux en ligne).</li>
      <li>Outils compl√©mentaires : <a href="https://www.apigee.com/" target="_blank">Google Apigee</a>, <a href="https://www.nginx.com/products/nginx-api-gateway/" target="_blank">NGINX API Gateway</a>.</li>
    </ul>
  </aside>
</section>

<!-- Slide 3: Communication synchrone - Principes -->
<section>
  <h2>Communication synchrone</h2>
  <ul>
    <li>Interaction directe: appel de service et attente de r√©ponse</li>
    <li>Protocole courant: HTTP(S) / gRPC</li>
    <li>Verrouillage du flux d'ex√©cution jusqu'√† la r√©ponse</li>
  </ul>
  <div class="mermaid">
    flowchart LR
      Client[Client]
      Service[Service]
      Client -- "Request" --> Service
      Service -- "Response" --> Client
  </div>
  <aside class="notes">
    <ul>
      <li>Dans un mod√®le synchrone, le client √©met une requ√™te et attend la r√©ponse : le flux est bloqu√© en attendant.</li>
      <li>Exemples courants : REST (HTTP/HTTPS), gRPC, SOAP.</li>
      <li>Analogie : comme passer un appel t√©l√©phonique : la conversation ne progresse que si l'interlocuteur r√©pond.</li>
      <li>Ce mod√®le offre une forte tra√ßabilit√© (un appel ‚Üî une r√©ponse), id√©al pour le debug.</li>
      <li>Outils open source : <a href="https://grpc.io/" target="_blank">gRPC</a>, <a href="https://expressjs.com/" target="_blank">Express.js</a> (Node.js), <a href="https://spring.io/projects/spring-boot" target="_blank">Spring Boot</a> (Java).</li>
      <li>‚ö†Ô∏è Attention √† la <b>d√©pendance de disponibilit√©</b> : si un service est lent ou indisponible, toute la cha√Æne s'arr√™te.</li>
      <li>Bonnes pratiques : ajouter des timeouts et des m√©canismes de retry, utiliser des circuit breakers.</li>
    </ul>
  </aside>
</section>

<!-- Slide 4: Communication synchrone - Avantages et inconv√©nients -->
<section>
  <h3>Avantages / Inconv√©nients</h3>
  <ul>
    <li><strong>Avantages:</strong> simplicit√©, tra√ßabilit√©, faible latence per√ßue</li>
    <li><strong>Inconv√©nients:</strong> couplage fort, points de blocage, moindre r√©silience</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>La simplicit√© et la visibilit√© du chemin d'ex√©cution facilitent le monitoring.</li>
      <li>Le couplage fort limite l'agilit√© : les √©quipes sont plus d√©pendantes les unes des autres.</li>
      <li>Utilisation du pattern <b>circuit breaker</b> (disjoncteur) : il coupe le flux si trop d'erreurs sont d√©tect√©es, pour √©viter une avalanche de pannes.</li>
      <li>√Ä √©viter dans les syst√®mes n√©cessitant une haute disponibilit√© ou devant absorber des pics de charge importants.</li>
      <li>Exemple : dans un SI bancaire, une requ√™te de virement peut √©chouer si le service anti-fraude n'est pas disponible √† l'instant t.</li>
      <li>Bonnes pratiques : isoler les d√©pendances critiques, monitorer les temps de r√©ponse, pr√©voir un fallback ou une file d'attente de secours.</li>
    </ul>
  </aside>
</section>

<!-- Slide 5: Communication asynchrone - Principes -->
<section>
  <h2>Communication asynchrone</h2>
  <ul>
    <li>√âchange de messages via broker (Kafka, RabbitMQ)</li>
    <li>Le producteur n'attend pas la r√©ponse du consommateur</li>
    <li>Mod√®les: pub/sub, request/async-response, notifications</li>
  </ul>
  <div class="mermaid">
    flowchart LR
      Producer[Producteur]
      Broker["Broker (Kafka, RabbitMQ)"]
      Consumer[Consommateur]
      Producer -- "Message" --> Broker
      Broker -- "Message" --> Consumer
  </div>
  <aside class="notes">
    <ul>
      <li>Ici, le producteur envoie un message dans une file ou un topic : il n'attend pas de r√©ponse imm√©diate, ce qui am√©liore la r√©silience et la mont√©e en charge.</li>
      <li>Mod√®les pub/sub (plusieurs consommateurs), ou point-√†-point (un seul destinataire).</li>
      <li>Analogie : poster une lettre (asynchrone) plut√¥t que t√©l√©phoner (synchrone) : la lettre arrivera quand elle pourra.</li>
      <li>Cas m√©tier : notification d'un paiement, traitement diff√©r√© d'un upload de document, diffusion de newsletters‚Ä¶</li>
      <li>Outils open source : <a href="https://kafka.apache.org/" target="_blank">Apache Kafka</a>, <a href="https://www.rabbitmq.com/" target="_blank">RabbitMQ</a>, <a href="https://activemq.apache.org/" target="_blank">ActiveMQ</a>.</li>
      <li>Pi√®ge √† √©viter : ne pas monitorer la saturation des files (dead letter queue).</li>
      <li>Best practice : documenter les sch√©mas d'√©v√©nements, pr√©voir un plan de migration lors de changements de structure.</li>
    </ul>
  </aside>
</section>

<!-- Slide 6: Communication asynchrone - Avantages et inconv√©nients -->
<section>
  <h3>Avantages / Inconv√©nients</h3>
  <ul>
    <li><strong>Avantages:</strong> d√©couplage, mont√©e en charge ind√©pendante, tol√©rance aux pannes</li>
    <li><strong>Inconv√©nients:</strong> complexit√© de traitement, gestion de la consistance, latence accrue</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>La <b>consistance √©ventuelle</b> (<i>eventual consistency</i>) signifie que le syst√®me mettra un certain temps avant que toutes les copies de la donn√©e soient √† jour.</li>
      <li>La latence est plus difficile √† pr√©dire, mais l'ensemble est plus robuste face aux pannes ponctuelles.</li>
      <li>Gestion des sch√©mas d'√©v√©nements : attention aux breaking changes, aux compatibilit√©s ascendantes/descendantes.</li>
      <li>Cas r√©el : la plateforme Netflix utilise massivement l'asynchrone pour la distribution de vid√©os et le suivi de logs utilisateurs.</li>
      <li>Bonnes pratiques : pr√©voir des outils de monitoring d√©di√©s (ex : Prometheus, Grafana), int√©grer des alertes sur la taille des files et les d√©lais de traitement.</li>
    </ul>
  </aside>
</section>

<!-- Slide 7: Event Sourcing - Concept -->
<section>
  <h2>Event Sourcing</h2>
  <ul>
    <li>Toutes les modifications d'√©tat sont stock√©es comme √©v√©nements immuables</li>
    <li>Le journal d'√©v√©nements devient la source de v√©rit√©</li>
    <li>Reconstruction de l'√©tat par relecture des √©v√©nements</li>
  </ul>
  <div class="mermaid">
    flowchart LR
      UserAction[Action utilisateur]
      EventStore[Event Store]
      Projection[Projection/Etat courant]
      UserAction -- "Ev√©nement" --> EventStore
      EventStore -- "Relecture" --> Projection
  </div>
  <aside class="notes">
    <ul>
      <li>Chaque √©v√©nement repr√©sente une modification d'√©tat (commande pass√©e, paiement valid√©‚Ä¶)</li>
      <li>Le <b>journal d'√©v√©nements</b> (event store) est le r√©f√©rentiel central : il permet de reconstituer l'√©tat actuel, d'investiguer les bugs par <b>replay</b>, de revenir en arri√®re (rollback).</li>
      <li>Analogie : un livre de comptes ou carnet de bord d'un navire, on sait tout ce qui s'est pass√© et on peut rejouer l'histoire.</li>
      <li>Bonnes pratiques : s'assurer de l'immuabilit√© des √©v√©nements, versionner les sch√©mas d'√©v√©nements.</li>
      <li>Outils open source : <a href="https://eventstore.com/" target="_blank">EventStoreDB</a>, <a href="https://axoniq.io/" target="_blank">Axon Framework</a> (Java), <a href="https://martinfowler.com/eaaDev/EventSourcing.html" target="_blank">martinfowler.com</a>.</li>
      <li>√Ä ne pas faire : stocker des donn√©es sensibles sans encryption dans l'event store, ou ignorer le volume croissant du journal.</li>
    </ul>
  </aside>
</section>

<!-- Slide 8: Event Sourcing - Cas d'usage et challenges -->
<section>
  <h3>Cas d'usage & challenges</h3>
  <ul>
    <li>Audit trail, versioning, replay pour d√©bogage</li>
    <li>Cr√©ation de snapshots pour optimiser la reconstruction</li>
    <li>Complexit√©: sch√©ma d'√©v√©nements, √©volutions, orchestration</li>
  </ul>
  <aside class="notes">
    <ul>
      <li><b>Audit trail</b> : indispensable pour l'audit r√©glementaire, ex : finance ou sant√©.</li>
      <li>Le <b>replay</b> permet de rejouer toute la vie d'un objet m√©tier pour reproduire un bug ou comprendre une anomalie.</li>
      <li><b>Snapshot</b> : ¬´ photo ¬ª prise r√©guli√®rement de l'√©tat courant, pour √©viter de rejouer tout le journal depuis l'origine.</li>
      <li>Gestion des √©volutions : pr√©voir le versioning des √©v√©nements, des scripts de migration, et documenter les projections.</li>
      <li>Orchestration : s'assurer que toutes les vues projet√©es se mettent √† jour correctement et g√©rer les √©checs de projection.</li>
      <li>Exemple concret : compte bancaire (toutes les op√©rations sont enregistr√©es, l'√©tat du compte est la somme de toutes les op√©rations), historique d'actions en jeu vid√©o, etc.</li>
    </ul>
  </aside>
</section>

<!-- Slide 9: CQRS - Concept -->
<section>
  <h2>CQRS (Command Query Responsibility Segregation)</h2>
  <ul>
    <li>S√©paration des mod√®les de lecture (Query) et d'√©criture (Command)</li>
    <li>Optimisation ind√©pendante pour chaque c√¥t√©</li>
    <li>Souvent combin√© √† Event Sourcing pour le mod√®le d'√©criture</li>
  </ul>
  <div class="mermaid">
    flowchart LR
      UI[UI/Client]
      CQRS[API CQRS]
      Command[Command Model]
      Query[Query Model]
      ES[Event Store]
      UI -- "Commande" --> CQRS
      CQRS -- "Command" --> Command
      Command -- "Ev√©nement" --> ES
      ES -- "Projection" --> Query
      CQRS -- "Lecture" --> Query
      Query -- "R√©sultat" --> UI
  </div>
  <aside class="notes">
    <ul>
      <li>CQRS = Command Query Responsibility Segregation : chaque action d'√©criture (commande) et de lecture passe par des mod√®les s√©par√©s.</li>
      <li>On peut alors scaler ind√©pendamment la lecture (ex : via une base NoSQL rapide) et l'√©criture (orient√©e √©v√©nement).</li>
      <li>Typiquement, on couple CQRS √† Event Sourcing pour maximiser la tra√ßabilit√© et la performance.</li>
      <li>Analogie : guichet unique versus guichets sp√©cialis√©s pour chaque op√©ration bancaire.</li>
      <li>Outils open source : <a href="https://axoniq.io/" target="_blank">Axon Framework</a>, <a href="https://github.com/jgauffin/griffin">Griffin CQRS</a> (.NET), <a href="https://mediatR.net/" target="_blank">MediatR</a> (.NET).</li>
      <li>√Ä ne pas faire : appliquer CQRS sur un simple CRUD ou dans des contextes √† faible volum√©trie, c'est trop complexe pour peu de b√©n√©fices.</li>
      <li>Voir : <a href="https://martinfowler.com/bliki/CQRS.html" target="_blank">Martin Fowler</a>.</li>
    </ul>
  </aside>
</section>

<!-- Slide 10: CQRS - Avantages et inconv√©nients -->
<section>
  <h3>Avantages / Inconv√©nients</h3>
  <ul>
    <li><strong>Avantages:</strong> scalabilit√©, performances, clart√© des responsabilit√©s</li>
    <li><strong>Inconv√©nients:</strong> complexit√©, consistance √©ventuelle, effort de synchronisation</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Permet de sp√©cialiser chaque mod√®le pour son usage, donc optimiser lecture et √©criture selon des exigences diff√©rentes.</li>
      <li>La <b>consistance √©ventuelle</b> : il existe toujours une l√©g√®re latence entre l'√©criture d'un √©v√©nement et sa disponibilit√© c√¥t√© lecture.</li>
      <li>Effort suppl√©mentaire pour la synchronisation, versioning, et monitoring.</li>
      <li>Ne convient pas √† tous les syst√®mes : sur un CRUD simple ou une petite √©quipe, c'est surdimensionn√©.</li>
      <li>Exp√©rience terrain : CQRS tr√®s utilis√© dans l'e-commerce (Amazon, Cdiscount) pour g√©rer la volum√©trie sur la consultation de catalogue vs. passage de commande.</li>
      <li>Pi√®ge : ne pas anticiper les besoins de reporting et d'administration sur la partie lecture.</li>
      <li>Best practice : bien documenter la s√©paration des responsabilit√©s, pr√©voir des outils de supervision d√©di√©s, surveiller la latence entre √©criture et disponibilit√© de lecture.</li>
    </ul>
  </aside>
</section>

<!-- Slide 11: Sources -->
<section>
  <h2>Sources</h2>
  <ul>
    <li><a href="https://aws.amazon.com/api-gateway/">AWS API Gateway</a></li>
    <li><a href="https://microservices.io/patterns/communication-style.html">Microservices Communication Styles</a></li>
    <li><a href="https://martinfowler.com/eaaDev/EventSourcing.html">Martin Fowler - Event Sourcing</a></li>
    <li><a href="https://martinfowler.com/bliki/CQRS.html">Martin Fowler - CQRS</a></li>
    <li><a href="https://konghq.com/">Kong API Gateway</a> (FR : <a href="https://www.it-connect.fr/kong-api-gateway-open-source/">Pr√©sentation</a>)</li>
    <li><a href="https://grafikart.fr/tutoriels/api-gateway-2258">Tutoriel API Gateway en fran√ßais (Grafikart)</a></li>
    <li><a href="https://www.it-connect.fr/levent-sourcing-cqrs-et-les-patterns-devenement/">Explication Event Sourcing & CQRS (fran√ßais)</a></li>
  </ul>
  <aside class="notes">
    <ul>
      <li>V√©rifi√© le 19 mai 2025, tous les liens sont actifs.</li>
      <li>Ajout de quelques ressources en fran√ßais pour les publics non anglophones.</li>
      <li>Se r√©f√©rer √† Microservices.io pour approfondir les patterns de communication et de r√©silience.</li>
    </ul>
  </aside>
</section>

<!-- Slide 12: Questions (Quiz) -->
<section>
  <h2>Questions</h2>
  <ol>
    <li>Quel est le r√¥le principal d'un API Gateway ?</li>
    <li>Donnez un avantage et un inconv√©nient de la communication synchrone.</li>
    <li>Expliquez bri√®vement l'Event Sourcing.</li>
    <li>Pourquoi s√©parer lecture et √©criture en CQRS ?</li>
    <li>(Vrai/Faux) Une API Gateway doit inclure toute la logique m√©tier du backend.</li>
    <li>(Vrai/Faux) En asynchrone, le producteur de message attend toujours la r√©ponse du consommateur.</li>
    <li>(Vrai/Faux) Event Sourcing facilite l'auditabilit√© et le rollback.</li>
  </ol>
  <aside class="notes">
    <ul>
      <li><b>1.</b> Centraliser le routage, la s√©curit√©, la gestion des acc√®s et le monitoring pour les APIs.</li>
      <li><b>2.</b> Avantage : simplicit√©/tra√ßabilit√© ; Inconv√©nient : couplage fort/moindre r√©silience.</li>
      <li><b>3.</b> Stocker chaque modification d'√©tat sous forme d'√©v√©nement immuable, permettant audit, replay et rollback.</li>
      <li><b>4.</b> Pour optimiser s√©par√©ment lecture (performance) et √©criture (audit, validations), et scaler chaque partie ind√©pendamment.</li>
      <li><b>5.</b> Faux : la logique m√©tier reste dans les services, la gateway s'occupe de l'orchestration et de la s√©curit√©.</li>
      <li><b>6.</b> Faux : en asynchrone, le producteur n'attend pas la r√©ponse, il poste et oublie.</li>
      <li><b>7.</b> Vrai : Event Sourcing est con√ßu pour faciliter l'auditabilit√© et le retour en arri√®re (rollback).</li>
    </ul>
  </aside>
</section>
