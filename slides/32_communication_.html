<!-- Slide 0: Titre -->
<section data-background-image="/public/images/titre_distribuees.jpg"
         data-background-size="cover"
         data-background-opacity="0.6">
  <h2 style="font-size:2.7em; color:#fff; text-shadow:1px 1px 10px #333;">
    Patterns de Communication & Architecture AvancÃ©e<br>
    <span style="font-size:0.65em; font-weight:normal;">API Gateway, Synchrone, Asynchrone, Event Sourcing, CQRS</span>
  </h2>
  <aside class="notes">
    <ul>
      <li>Bienvenue, introduction du thÃ¨me principal du module.</li>
      <li>Objectif : comprendre les patterns essentiels des applications distribuÃ©es modernes.</li>
      <li>Annonce du fil rouge : API Gateway, communications, Event Sourcing, CQRS.</li>
    </ul>
  </aside>
</section>
<section>
  <h2>Sommaire</h2>
  <ul>
    <li>ğŸ¯ <strong>Introduction</strong> : dÃ©finitions et enjeux</li>
    <li>ğŸšª <strong>API Gateway</strong> : rÃ´le, cas dâ€™usage, bonnes pratiques</li>
    <li>ğŸ”— <strong>Communication synchrone</strong> : principes, avantages/inconvÃ©nients</li>
    <li>ğŸ“¬ <strong>Communication asynchrone</strong> : patterns, brokers, rÃ©silience</li>
    <li>ğŸ“ <strong>Event Sourcing</strong> : concept, cas dâ€™usage, dÃ©fis</li>
    <li>ğŸ”„ <strong>CQRS</strong> : principes, exemples, limites</li>
    <li>â“ <strong>Quiz & questions</strong></li>
    <li>ğŸ“š <strong>Sources & liens utiles</strong></li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Tour rapide du plan : chaque partie apporte une brique de comprÃ©hension sur les architectures distribuÃ©es.</li>
      <li>Annonce de la prÃ©sence de quiz et de sources Ã  la fin.</li>
    </ul>
  </aside>
</section>
<!-- Slide 1: API Gateway - DÃ©finition -->
<section>
  <h2>API Gateway</h2>
  <ul>
    <li>Point d'entrÃ©e unique pour des APIs REST ou WebSocket</li>
    <li>DÃ©couple les clients des services backend</li>
    <li>GÃ¨re routage, authentification, limitation de dÃ©bit, monitoring</li>
  </ul>
  <div class="mermaid">
    flowchart LR
      Client[Client]
      APIGW[API Gateway]
      Service1[Microservice 1]
      Service2[Microservice 2]
      Service3[Microservice 3]
      Client --> APIGW
      APIGW --> Service1
      APIGW --> Service2
      APIGW --> Service3
  </div>
  <aside class="notes">
    <ul>
      <li>Un <b>API Gateway</b> agit comme la porte dâ€™entrÃ©e unique (Â« front door Â») centralisant le trafic entrant, la sÃ©curitÃ© et la surveillance de vos microservices.</li>
      <li>Il gÃ¨re le routage, l'authentification, le monitoring, la <b>limitation de dÃ©bit</b> (<i>rate limiting</i>) et la transformation de requÃªtes/rÃ©ponses.</li>
      <li>DÃ©couplageÂ : le client ne connaÃ®t pas les dÃ©tails des services backend ni leurs Ã©volutions.</li>
      <li>AnalogieÂ : câ€™est le portier dâ€™un immeuble, qui filtre les visiteurs et les oriente vers les bons Ã©tages.</li>
      <li>OutilsÂ : <a href="https://konghq.com/" target="_blank">Kong</a> (open source), <a href="https://tyk.io/" target="_blank">Tyk</a>, <a href="https://aws.amazon.com/api-gateway/" target="_blank">AWS API Gateway</a>.</li>
      <li>Ã€ ne pas faireÂ : ne surchargez pas votre gateway avec toute la logique mÃ©tier â€” restez sur l'orchestration et la sÃ©curitÃ©.</li>
    </ul>
  </aside>
</section>

<!-- Slide 2: API Gateway - Cas d'usage et exemples -->
<section>
  <h3>Cas d'usage et exemples</h3>
  <ul>
    <li>Exposition d'un backend serverless (Lambda, Azure Functions)</li>
    <li>Aggregation de plusieurs services en un seul endpoint</li>
    <li>Migration de microservices en versions gÃ©rÃ©es</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Exposer une fonction <b>serverless</b> (AWS Lambda, Azure Function, GCP Function) comme API HTTP facilement.</li>
      <li>AgrÃ©gationÂ : exemple dâ€™un endpoint â€œMon Profilâ€ qui compose les infos utilisateur, commandes et notifications via plusieurs microservices.</li>
      <li>Gestion des versions : le Gateway permet de migrer vers de nouvelles versions sans perturber les clients.</li>
      <li>ExpÃ©rience terrainÂ : les API Gateway sont utilisÃ©s dans toutes les architectures modernes Ã  grande Ã©chelle (e-commerce, SaaS, jeux en ligne).</li>
      <li>Outils complÃ©mentairesÂ : <a href="https://www.apigee.com/" target="_blank">Google Apigee</a>, <a href="https://www.nginx.com/products/nginx-api-gateway/" target="_blank">NGINX API Gateway</a>.</li>
    </ul>
  </aside>
</section>

<!-- Slide 3: Communication synchrone - Principes -->
<section>
  <h2>Communication synchrone</h2>
  <ul>
    <li>Interaction directe: appel de service et attente de rÃ©ponse</li>
    <li>Protocole courant: HTTP(S) / gRPC</li>
    <li>Verrouillage du flux d'exÃ©cution jusqu'Ã  la rÃ©ponse</li>
  </ul>
  <div class="mermaid">
    flowchart LR
      Client[Client]
      Service[Service]
      Client -- "Request" --> Service
      Service -- "Response" --> Client
  </div>
  <aside class="notes">
    <ul>
      <li>Dans un modÃ¨le synchrone, le client Ã©met une requÃªte et attend la rÃ©ponseÂ : le flux est bloquÃ© en attendant.</li>
      <li>Exemples courantsÂ : REST (HTTP/HTTPS), gRPC, SOAP.</li>
      <li>AnalogieÂ : comme passer un appel tÃ©lÃ©phoniqueÂ : la conversation ne progresse que si lâ€™interlocuteur rÃ©pond.</li>
      <li>Ce modÃ¨le offre une forte traÃ§abilitÃ© (un appel â†” une rÃ©ponse), idÃ©al pour le debug.</li>
      <li>Outils open sourceÂ : <a href="https://grpc.io/" target="_blank">gRPC</a>, <a href="https://expressjs.com/" target="_blank">Express.js</a> (Node.js), <a href="https://spring.io/projects/spring-boot" target="_blank">Spring Boot</a> (Java).</li>
      <li>âš ï¸ Attention Ã  la <b>dÃ©pendance de disponibilitÃ©</b> : si un service est lent ou indisponible, toute la chaÃ®ne sâ€™arrÃªte.</li>
      <li>Bonnes pratiques : ajouter des timeouts et des mÃ©canismes de retry, utiliser des circuit breakers.</li>
    </ul>
  </aside>
</section>

<!-- Slide 4: Communication synchrone - Avantages et inconvÃ©nients -->
<section>
  <h3>Avantages / InconvÃ©nients</h3>
  <ul>
    <li><strong>Avantages:</strong> simplicitÃ©, traÃ§abilitÃ©, faible latence perÃ§ue</li>
    <li><strong>InconvÃ©nients:</strong> couplage fort, points de blocage, moindre rÃ©silience</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>La simplicitÃ© et la visibilitÃ© du chemin dâ€™exÃ©cution facilitent le monitoring.</li>
      <li>Le couplage fort limite lâ€™agilitÃ© : les Ã©quipes sont plus dÃ©pendantes les unes des autres.</li>
      <li>Utilisation du pattern <b>circuit breaker</b> (disjoncteur) : il coupe le flux si trop dâ€™erreurs sont dÃ©tectÃ©es, pour Ã©viter une avalanche de pannes.</li>
      <li>Ã€ Ã©viter dans les systÃ¨mes nÃ©cessitant une haute disponibilitÃ© ou devant absorber des pics de charge importants.</li>
      <li>ExempleÂ : dans un SI bancaire, une requÃªte de virement peut Ã©chouer si le service anti-fraude nâ€™est pas disponible Ã  lâ€™instant t.</li>
      <li>Bonnes pratiques : isoler les dÃ©pendances critiques, monitorer les temps de rÃ©ponse, prÃ©voir un fallback ou une file dâ€™attente de secours.</li>
    </ul>
  </aside>
</section>

<!-- Slide 5: Communication asynchrone - Principes -->
<section>
  <h2>Communication asynchrone</h2>
  <ul>
    <li>Ã‰change de messages via broker (Kafka, RabbitMQ)</li>
    <li>Le producteur n'attend pas la rÃ©ponse du consommateur</li>
    <li>ModÃ¨les: pub/sub, request/async-response, notifications</li>
  </ul>
  <div class="mermaid">
    flowchart LR
      Producer[Producteur]
      Broker["Broker (Kafka, RabbitMQ)"]
      Consumer[Consommateur]
      Producer -- "Message" --> Broker
      Broker -- "Message" --> Consumer
  </div>
  <aside class="notes">
    <ul>
      <li>Ici, le producteur envoie un message dans une file ou un topicÂ : il nâ€™attend pas de rÃ©ponse immÃ©diate, ce qui amÃ©liore la rÃ©silience et la montÃ©e en charge.</li>
      <li>ModÃ¨les pub/sub (plusieurs consommateurs), ou point-Ã -point (un seul destinataire).</li>
      <li>Analogie : poster une lettre (asynchrone) plutÃ´t que tÃ©lÃ©phoner (synchrone)Â : la lettre arrivera quand elle pourra.</li>
      <li>Cas mÃ©tier : notification dâ€™un paiement, traitement diffÃ©rÃ© dâ€™un upload de document, diffusion de newslettersâ€¦</li>
      <li>Outils open sourceÂ : <a href="https://kafka.apache.org/" target="_blank">Apache Kafka</a>, <a href="https://www.rabbitmq.com/" target="_blank">RabbitMQ</a>, <a href="https://activemq.apache.org/" target="_blank">ActiveMQ</a>.</li>
      <li>PiÃ¨ge Ã  Ã©viter : ne pas monitorer la saturation des files (dead letter queue).</li>
      <li>Best practice : documenter les schÃ©mas dâ€™Ã©vÃ©nements, prÃ©voir un plan de migration lors de changements de structure.</li>
    </ul>
  </aside>
</section>

<!-- Slide 6: Communication asynchrone - Avantages et inconvÃ©nients -->
<section>
  <h3>Avantages / InconvÃ©nients</h3>
  <ul>
    <li><strong>Avantages:</strong> dÃ©couplage, montÃ©e en charge indÃ©pendante, tolÃ©rance aux pannes</li>
    <li><strong>InconvÃ©nients:</strong> complexitÃ© de traitement, gestion de la consistance, latence accrue</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>La <b>consistance Ã©ventuelle</b> (<i>eventual consistency</i>) signifie que le systÃ¨me mettra un certain temps avant que toutes les copies de la donnÃ©e soient Ã  jour.</li>
      <li>La latence est plus difficile Ã  prÃ©dire, mais lâ€™ensemble est plus robuste face aux pannes ponctuelles.</li>
      <li>Gestion des schÃ©mas dâ€™Ã©vÃ©nementsÂ : attention aux breaking changes, aux compatibilitÃ©s ascendantes/descendantes.</li>
      <li>Cas rÃ©elÂ : la plateforme Netflix utilise massivement lâ€™asynchrone pour la distribution de vidÃ©os et le suivi de logs utilisateurs.</li>
      <li>Bonnes pratiquesÂ : prÃ©voir des outils de monitoring dÃ©diÃ©s (exÂ : Prometheus, Grafana), intÃ©grer des alertes sur la taille des files et les dÃ©lais de traitement.</li>
    </ul>
  </aside>
</section>

<!-- Slide 7: Event Sourcing - Concept -->
<section>
  <h2>Event Sourcing</h2>
  <ul>
    <li>Toutes les modifications d'Ã©tat sont stockÃ©es comme Ã©vÃ©nements immuables</li>
    <li>Le journal d'Ã©vÃ©nements devient la source de vÃ©ritÃ©</li>
    <li>Reconstruction de l'Ã©tat par relecture des Ã©vÃ©nements</li>
  </ul>
  <div class="mermaid">
    flowchart LR
      UserAction[Action utilisateur]
      EventStore[Event Store]
      Projection[Projection/Etat courant]
      UserAction -- "EvÃ©nement" --> EventStore
      EventStore -- "Relecture" --> Projection
  </div>
  <aside class="notes">
    <ul>
      <li>Chaque Ã©vÃ©nement reprÃ©sente une modification dâ€™Ã©tat (commande passÃ©e, paiement validÃ©â€¦)</li>
      <li>Le <b>journal dâ€™Ã©vÃ©nements</b> (event store) est le rÃ©fÃ©rentiel centralÂ : il permet de reconstituer lâ€™Ã©tat actuel, dâ€™investiguer les bugs par <b>replay</b>, de revenir en arriÃ¨re (rollback).</li>
      <li>AnalogieÂ : un livre de comptes ou carnet de bord dâ€™un navire, on sait tout ce qui sâ€™est passÃ© et on peut rejouer lâ€™histoire.</li>
      <li>Bonnes pratiquesÂ : sâ€™assurer de lâ€™immuabilitÃ© des Ã©vÃ©nements, versionner les schÃ©mas dâ€™Ã©vÃ©nements.</li>
      <li>Outils open sourceÂ : <a href="https://eventstore.com/" target="_blank">EventStoreDB</a>, <a href="https://axoniq.io/" target="_blank">Axon Framework</a> (Java), <a href="https://martinfowler.com/eaaDev/EventSourcing.html" target="_blank">martinfowler.com</a>.</li>
      <li>Ã€ ne pas faireÂ : stocker des donnÃ©es sensibles sans encryption dans lâ€™event store, ou ignorer le volume croissant du journal.</li>
    </ul>
  </aside>
</section>

<!-- Slide 8: Event Sourcing - Cas d'usage et challenges -->
<section>
  <h3>Cas d'usage & challenges</h3>
  <ul>
    <li>Audit trail, versioning, replay pour dÃ©bogage</li>
    <li>CrÃ©ation de snapshots pour optimiser la reconstruction</li>
    <li>ComplexitÃ©: schÃ©ma d'Ã©vÃ©nements, Ã©volutions, orchestration</li>
  </ul>
  <aside class="notes">
    <ul>
      <li><b>Audit trail</b>Â : indispensable pour lâ€™audit rÃ©glementaire, exÂ : finance ou santÃ©.</li>
      <li>Le <b>replay</b> permet de rejouer toute la vie dâ€™un objet mÃ©tier pour reproduire un bug ou comprendre une anomalie.</li>
      <li><b>Snapshot</b>Â : Â«Â photoÂ Â» prise rÃ©guliÃ¨rement de lâ€™Ã©tat courant, pour Ã©viter de rejouer tout le journal depuis lâ€™origine.</li>
      <li>Gestion des Ã©volutions : prÃ©voir le versioning des Ã©vÃ©nements, des scripts de migration, et documenter les projections.</li>
      <li>Orchestration : sâ€™assurer que toutes les vues projetÃ©es se mettent Ã  jour correctement et gÃ©rer les Ã©checs de projection.</li>
      <li>Exemple concretÂ : compte bancaire (toutes les opÃ©rations sont enregistrÃ©es, lâ€™Ã©tat du compte est la somme de toutes les opÃ©rations), historique dâ€™actions en jeu vidÃ©o, etc.</li>
    </ul>
  </aside>
</section>

<!-- Slide 9: CQRS - Concept -->
<section>
  <h2>CQRS (Command Query Responsibility Segregation)</h2>
  <ul>
    <li>SÃ©paration des modÃ¨les de lecture (Query) et d'Ã©criture (Command)</li>
    <li>Optimisation indÃ©pendante pour chaque cÃ´tÃ©</li>
    <li>Souvent combinÃ© Ã  Event Sourcing pour le modÃ¨le d'Ã©criture</li>
  </ul>
  <div class="mermaid">
    flowchart LR
      UI[UI/Client]
      CQRS[API CQRS]
      Command[Command Model]
      Query[Query Model]
      ES[Event Store]
      UI -- "Commande" --> CQRS
      CQRS -- "Command" --> Command
      Command -- "EvÃ©nement" --> ES
      ES -- "Projection" --> Query
      CQRS -- "Lecture" --> Query
      Query -- "RÃ©sultat" --> UI
  </div>
  <aside class="notes">
    <ul>
      <li>CQRS = Command Query Responsibility SegregationÂ : chaque action dâ€™Ã©criture (commande) et de lecture passe par des modÃ¨les sÃ©parÃ©s.</li>
      <li>On peut alors scaler indÃ©pendamment la lecture (exÂ : via une base NoSQL rapide) et lâ€™Ã©criture (orientÃ©e Ã©vÃ©nement).</li>
      <li>Typiquement, on couple CQRS Ã  Event Sourcing pour maximiser la traÃ§abilitÃ© et la performance.</li>
      <li>AnalogieÂ : guichet unique versus guichets spÃ©cialisÃ©s pour chaque opÃ©ration bancaire.</li>
      <li>Outils open sourceÂ : <a href="https://axoniq.io/" target="_blank">Axon Framework</a>, <a href="https://github.com/jgauffin/griffin">Griffin CQRS</a> (.NET), <a href="https://mediatR.net/" target="_blank">MediatR</a> (.NET).</li>
      <li>Ã€ ne pas faireÂ : appliquer CQRS sur un simple CRUD ou dans des contextes Ã  faible volumÃ©trie, câ€™est trop complexe pour peu de bÃ©nÃ©fices.</li>
      <li>Voir : <a href="https://martinfowler.com/bliki/CQRS.html" target="_blank">Martin Fowler</a>.</li>
    </ul>
  </aside>
</section>

<!-- Slide 10: CQRS - Avantages et inconvÃ©nients -->
<section>
  <h3>Avantages / InconvÃ©nients</h3>
  <ul>
    <li><strong>Avantages:</strong> scalabilitÃ©, performances, clartÃ© des responsabilitÃ©s</li>
    <li><strong>InconvÃ©nients:</strong> complexitÃ©, consistance Ã©ventuelle, effort de synchronisation</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Permet de spÃ©cialiser chaque modÃ¨le pour son usage, donc optimiser lecture et Ã©criture selon des exigences diffÃ©rentes.</li>
      <li>La <b>consistance Ã©ventuelle</b>Â : il existe toujours une lÃ©gÃ¨re latence entre lâ€™Ã©criture dâ€™un Ã©vÃ©nement et sa disponibilitÃ© cÃ´tÃ© lecture.</li>
      <li>Effort supplÃ©mentaire pour la synchronisation, versioning, et monitoring.</li>
      <li>Ne convient pas Ã  tous les systÃ¨mesÂ : sur un CRUD simple ou une petite Ã©quipe, câ€™est surdimensionnÃ©.</li>
      <li>ExpÃ©rience terrainÂ : CQRS trÃ¨s utilisÃ© dans lâ€™e-commerce (Amazon, Cdiscount) pour gÃ©rer la volumÃ©trie sur la consultation de catalogue vs. passage de commande.</li>
      <li>PiÃ¨geÂ : ne pas anticiper les besoins de reporting et dâ€™administration sur la partie lecture.</li>
      <li>Best practiceÂ : bien documenter la sÃ©paration des responsabilitÃ©s, prÃ©voir des outils de supervision dÃ©diÃ©s, surveiller la latence entre Ã©criture et disponibilitÃ© de lecture.</li>
    </ul>
  </aside>
</section>

<!-- Slide 11: Sources -->
<section>
  <h2>Sources</h2>
  <ul>
    <li><a href="https://aws.amazon.com/api-gateway/">AWS API Gateway</a></li>
    <li><a href="https://microservices.io/patterns/communication-style.html">Microservices Communication Styles</a></li>
    <li><a href="https://martinfowler.com/eaaDev/EventSourcing.html">Martin Fowler - Event Sourcing</a></li>
    <li><a href="https://martinfowler.com/bliki/CQRS.html">Martin Fowler - CQRS</a></li>
    <li><a href="https://konghq.com/">Kong API Gateway</a> (FR : <a href="https://www.it-connect.fr/kong-api-gateway-open-source/">PrÃ©sentation</a>)</li>
    <li><a href="https://grafikart.fr/tutoriels/api-gateway-2258">Tutoriel API Gateway en franÃ§ais (Grafikart)</a></li>
    <li><a href="https://www.it-connect.fr/levent-sourcing-cqrs-et-les-patterns-devenement/">Explication Event Sourcing & CQRS (franÃ§ais)</a></li>
  </ul>
  <aside class="notes">
    <ul>
      <li>VÃ©rifiÃ© le 19 mai 2025, tous les liens sont actifs.</li>
      <li>Ajout de quelques ressources en franÃ§ais pour les publics non anglophones.</li>
      <li>Se rÃ©fÃ©rer Ã  Microservices.io pour approfondir les patterns de communication et de rÃ©silience.</li>
    </ul>
  </aside>
</section>

<!-- Slide 12: Questions (Quiz) -->
<section>
  <h2>Questions</h2>
  <ol>
    <li>Quel est le rÃ´le principal d'un API Gateway ?</li>
    <li>Donnez un avantage et un inconvÃ©nient de la communication synchrone.</li>
    <li>Expliquez briÃ¨vement l'Event Sourcing.</li>
    <li>Pourquoi sÃ©parer lecture et Ã©criture en CQRS ?</li>
    <li>(Vrai/Faux) Une API Gateway doit inclure toute la logique mÃ©tier du backend.</li>
    <li>(Vrai/Faux) En asynchrone, le producteur de message attend toujours la rÃ©ponse du consommateur.</li>
    <li>(Vrai/Faux) Event Sourcing facilite lâ€™auditabilitÃ© et le rollback.</li>
  </ol>
  <aside class="notes">
    <ul>
      <li><b>1.</b> Centraliser le routage, la sÃ©curitÃ©, la gestion des accÃ¨s et le monitoring pour les APIs.</li>
      <li><b>2.</b> AvantageÂ : simplicitÃ©/traÃ§abilitÃ© ; InconvÃ©nientÂ : couplage fort/moindre rÃ©silience.</li>
      <li><b>3.</b> Stocker chaque modification dâ€™Ã©tat sous forme dâ€™Ã©vÃ©nement immuable, permettant audit, replay et rollback.</li>
      <li><b>4.</b> Pour optimiser sÃ©parÃ©ment lecture (performance) et Ã©criture (audit, validations), et scaler chaque partie indÃ©pendamment.</li>
      <li><b>5.</b> FauxÂ : la logique mÃ©tier reste dans les services, la gateway sâ€™occupe de lâ€™orchestration et de la sÃ©curitÃ©.</li>
      <li><b>6.</b> FauxÂ : en asynchrone, le producteur nâ€™attend pas la rÃ©ponse, il poste et oublie.</li>
      <li><b>7.</b> VraiÂ : Event Sourcing est conÃ§u pour faciliter lâ€™auditabilitÃ© et le retour en arriÃ¨re (rollback).</li>
    </ul>
  </aside>
</section>
