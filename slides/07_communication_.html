<!-- Slide 1: API Gateway - Définition -->
<section>
  <h2>API Gateway</h2>
  <ul>
    <li>Point d'entrée unique pour des APIs REST ou WebSocket</li>
    <li>Découple les clients des services backend</li>
    <li>Gère routage, authentification, limitation de débit, monitoring</li>
  </ul>
  <aside class="notes">
    Expliquez qu'un API Gateway sert de "front door" aux microservices. Soulignez l'importance de la gestion du trafic et de la sécurité.
  </aside>
</section>

<!-- Slide 2: API Gateway - Cas d'usage et exemples -->
<section>
  <h3>Cas d'usage et exemples</h3>
  <ul>
    <li>Exposition d'un backend serverless (Lambda, Azure Functions)</li>
    <li>Aggregation de plusieurs services en un seul endpoint</li>
    <li>Migration de microservices en versions gérées</li>
  </ul>
  <aside class="notes">
    Présenter un exemple AWS API Gateway (https://aws.amazon.com/api-gateway/) et ses principales fonctionnalités.
  </aside>
</section>

<!-- Slide 3: Communication synchrone - Principes -->
<section>
  <h2>Communication synchrone</h2>
  <ul>
    <li>Interaction directe: appel de service et attente de réponse</li>
    <li>Protocole courant: HTTP(S) / gRPC</li>
    <li>Verrouillage du flux d'exécution jusqu'à la réponse</li>
  </ul>
  <aside class="notes">
    Insister sur le modèle request-response et la forte dépendance en disponibilité.
  </aside>
</section>

<!-- Slide 4: Communication synchrone - Avantages et inconvénients -->
<section>
  <h3>Avantages / Inconvénients</h3>
  <ul>
    <li><strong>Avantages:</strong> simplicité, traçabilité, faible latence perçue</li>
    <li><strong>Inconvénients:</strong> couplage fort, points de blocage, moindre résilience</li>
  </ul>
  <aside class="notes">
    Donnez un exemple de circuit breaker pour mitiger les pannes dans un appel synchrone.
  </aside>
</section>

<!-- Slide 5: Communication asynchrone - Principes -->
<section>
  <h2>Communication asynchrone</h2>
  <ul>
    <li>Échange de messages via broker (Kafka, RabbitMQ)</li>
    <li>Le producteur n'attend pas la réponse du consommateur</li>
    <li>Modèles: pub/sub, request/async-response, notifications</li>
  </ul>
  <aside class="notes">
    Expliquer comment le découplage permet une meilleure résilience et scalabilité (https://microservices.io/patterns/communication-style.html).
  </aside>
</section>

<!-- Slide 6: Communication asynchrone - Avantages et inconvénients -->
<section>
  <h3>Avantages / Inconvénients</h3>
  <ul>
    <li><strong>Avantages:</strong> découplage, montée en charge indépendante, tolérance aux pannes</li>
    <li><strong>Inconvénients:</strong> complexité de traitement, gestion de la consistance, latence accrue</li>
  </ul>
  <aside class="notes">
    Mentionner l'eventual consistency et la gestion des schémas d'événements.
  </aside>
</section>

<!-- Slide 7: Event Sourcing - Concept -->
<section>
  <h2>Event Sourcing</h2>
  <ul>
    <li>Toutes les modifications d'état sont stockées comme événements immuables</li>
    <li>Le journal d'événements devient la source de vérité</li>
    <li>Reconstruction de l'état par relecture des événements</li>
  </ul>
  <aside class="notes">
    Introduire le concept via l'article de Martin Fowler: martinfowler.com/eaaDev/EventSourcing.html.
  </aside>
</section>

<!-- Slide 8: Event Sourcing - Cas d'usage et challenges -->
<section>
  <h3>Cas d'usage & challenges</h3>
  <ul>
    <li>Audit trail, versioning, replay pour débogage</li>
    <li>Création de snapshots pour optimiser la reconstruction</li>
    <li>Complexité: schéma d'événements, évolutions, orchestration</li>
  </ul>
  <aside class="notes">
    Expliquer le besoin de snapshots et de gestion des versions des événements.
  </aside>
</section>

<!-- Slide 9: CQRS - Concept -->
<section>
  <h2>CQRS (Command Query Responsibility Segregation)</h2>
  <ul>
    <li>Séparation des modèles de lecture (Query) et d'écriture (Command)</li>
    <li>Optimisation indépendante pour chaque côté</li>
    <li>Souvent combiné à Event Sourcing pour le modèle d'écriture</li>
  </ul>
  <aside class="notes">
    Citer la définition de Martin Fowler: martinfowler.com/bliki/CQRS.html.
  </aside>
</section>

<!-- Slide 10: CQRS - Avantages et inconvénients -->
<section>
  <h3>Avantages / Inconvénients</h3>
  <ul>
    <li><strong>Avantages:</strong> scalabilité, performances, clarté des responsabilités</li>
    <li><strong>Inconvénients:</strong> complexité, consistance éventuelle, effort de synchronisation</li>
  </ul>
  <aside class="notes">
    Insister sur la gestion de la latence de mise à jour du modèle de lecture.
  </aside>
</section>

<!-- Slide 11: Sources -->
<section>
  <h2>Sources</h2>
  <ul>
    <li><a href="https://aws.amazon.com/api-gateway/">AWS API Gateway</a></li>
    <li><a href="https://microservices.io/patterns/communication-style.html">Microservices Communication Styles</a></li>
    <li><a href="https://martinfowler.com/eaaDev/EventSourcing.html">Martin Fowler - Event Sourcing</a></li>
    <li><a href="https://martinfowler.com/bliki/CQRS.html">Martin Fowler - CQRS</a></li>
  </ul>
  <aside class="notes">
    Vérifié le 19 mai 2025, tous les liens sont actifs.
  </aside>
</section>

<!-- Slide 12: Questions -->
<section>
  <h2>Questions</h2>
  <ol>
    <li>Quel est le rôle principal d'un API Gateway ?</li>
    <li>Donnez un avantage et un inconvénient de la communication synchrone.</li>
    <li>Expliquez brièvement l'Event Sourcing.</li>
    <li>Pourquoi séparer lecture et écriture en CQRS ?</li>
  </ol>
  <aside class="notes">
    <strong>Réponses :</strong>
    1. Centraliser routage, sécurité et monitoring des appels API.
    2. Avantage : simplicité ; Inconvénient : couplage fort.
    3. Stockage immuable de chaque changement d'état sous forme d'événements.
    4. Pour optimiser et scaler indépendamment chaque modèle.
  </aside>
</section>
