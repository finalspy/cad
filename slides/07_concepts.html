<!-- Slide d‚Äôintroduction g√©n√©rale -->
<section data-background-image="/public/images/titre_concepts.jpg" 
          data-background-size="cover"
          data-background-opacity="0.5">
  <h1>Concepts cl√©s des applications distribu√©es</h1>
  <aside class="notes">
    Pr√©sentation des notions fondamentales pour comprendre et concevoir des syst√®mes distribu√©s modernes.
  </aside>
</section>

<!-- Organisation g√©n√©rale -->
<section>
  <h2>Organisation des concepts</h2>
  <ul>
    <li>üî∫ Th√©or√®mes fondamentaux</li>
    <li>üß© Architecture et Design</li>
    <li>üõ°Ô∏è R√©silience et Scalabilit√©</li>
    <li>üß™ Tests et Observabilit√©</li>
    <li>üß† Gouvernance et √âquipes</li>
  </ul>
  <aside class="notes">
    Voici les cinq grands ensembles qui structurent ce module. Nous allons explorer chaque groupe de concepts √† travers des exemples concrets.
  </aside>
</section>

<!-- === SECTION 1 : Th√©or√®mes fondamentaux === -->
<section>
  <h2>üî∫ Th√©or√®mes fondamentaux</h2>
  <ul>
    <li>Th√©or√®me de Brewer (CAP)</li>
    <li>ACID / BASE</li>
    <!--li>Th√©or√®me de FLP</li>
    <li>Th√©or√®me de Lamport</li>
    <li>Th√©or√®me de PACELC</li-->
  </ul>
  <aside class="notes">
    Ces th√©or√®mes posent les limites th√©oriques des syst√®mes distribu√©s. Ils influencent tous les choix techniques ult√©rieurs.
  </aside>
</section>

<section>
  <h2>CAP Theorem</h2>
  <ul>
    <li><strong>Consistency</strong>: m√™me valeur pour tous les n≈ìuds</li>
    <li><strong>Availability</strong>: r√©ponse √† chaque requ√™te</li>
    <li><strong>Partition Tolerance</strong>: robustesse en cas de rupture r√©seau</li>
  </ul>
  <aside class="notes">
    Dans un syst√®me distribu√©, on ne peut garantir les trois √† la fois. CAP nous oblige √† faire des compromis.
  </aside>
</section>

<section>
  <h2>üî∫ CAP Theorem</h2>
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/CAP_theorem.svg/500px-CAP_theorem.svg.png" alt="Diagramme CAP" style="max-height: 400px;" />
  <aside class="notes">
    Le th√©or√®me CAP (Brewer, 2000) dit qu‚Äôun syst√®me distribu√© ne peut garantir simultan√©ment Coh√©rence, Disponibilit√© et Tol√©rance au partitionnement.  
    Il faut choisir deux propri√©t√©s selon le besoin.
  </aside>
</section>

<section>
  <h2>Les 3 propri√©t√©s CAP</h2>
  <ul>
    <li><strong>C</strong> ‚Äì Consistency : Tous les n≈ìuds voient les m√™mes donn√©es en m√™me temps.</li>
    <li><strong>A</strong> ‚Äì Availability : Chaque requ√™te re√ßoit une r√©ponse, m√™me en cas de panne.</li>
    <li><strong>P</strong> ‚Äì Partition Tolerance : Le syst√®me continue √† fonctionner malgr√© des d√©faillances r√©seau.</li>
  </ul>
  <aside class="notes">
    Lorsqu‚Äôune partition r√©seau survient, vous devez sacrifier soit la coh√©rence soit la disponibilit√©. Ce choix d√©pend du cas d‚Äôusage.
  </aside>
</section>

<section>
  <h2>üü¢ CA : Consistency + Availability</h2>
  <ul>
    <li><strong>Avantages :</strong> r√©ponses coh√©rentes et toujours disponibles tant que le r√©seau est fiable</li>
    <li><strong>Inconv√©nients :</strong> si une partition survient, le syst√®me devient indisponible</li>
    <li><strong>Cas d‚Äôusage :</strong> syst√®mes en cluster local (pas r√©partis sur Internet)</li>
    <li><strong>Bases de donn√©es :</strong> PostgreSQL, Oracle (hors configuration distribu√©e)</li>
  </ul>
  <aside class="notes">
    Ce mod√®le est adapt√© aux syst√®mes centralis√©s ou avec r√©seau fiable (cluster en LAN).  
    D√®s qu'une partition r√©seau appara√Æt, le syst√®me pr√©f√®re ne plus r√©pondre plut√¥t que risquer l'incoh√©rence.
  </aside>
</section>

<section>
  <h2>üü° AP : Availability + Partition Tolerance</h2>
  <ul>
    <li><strong>Avantages :</strong> haute disponibilit√© m√™me en cas de partitions</li>
    <li><strong>Inconv√©nients :</strong> possible incoh√©rence temporaire des donn√©es</li>
    <li><strong>Cas d‚Äôusage :</strong> syst√®mes web hautement disponibles (r√©seaux distribu√©s mondiaux)</li>
    <li><strong>Bases de donn√©es :</strong> CouchDB, Cassandra, DynamoDB</li>
  </ul>
  <aside class="notes">
    Ici, on accepte des lectures diff√©rentes ou des √©critures concurrentes, en √©change de la disponibilit√©.  
    On vise la scalabilit√© mondiale, quitte √† g√©rer des conflits plus tard (consistance √©ventuelle).
  </aside>
</section>

<section>
  <h2>üîµ CP : Consistency + Partition Tolerance</h2>
  <ul>
    <li><strong>Avantages :</strong> forte coh√©rence m√™me en pr√©sence de partitions</li>
    <li><strong>Inconv√©nients :</strong> certaines requ√™tes √©chouent (sacrifiant la disponibilit√©)</li>
    <li><strong>Cas d‚Äôusage :</strong> syst√®mes bancaires, r√©servations</li>
    <li><strong>Bases de donn√©es :</strong> MongoDB (avec writeConcern √©lev√©), HBase, Zookeeper</li>
  </ul>
  <aside class="notes">
    Priorise la coh√©rence √† tout prix : le syst√®me peut refuser une op√©ration si la coh√©rence est incertaine.  
    Ce choix est commun pour les cas critiques comme les paiements ou r√©servations.
  </aside>
</section>


<section>
  <h2>üì¶ Bases de donn√©es et mod√®le CAP</h2>
  <table style="font-size: 0.8em;">
    <thead>
      <tr>
        <th>Type</th>
        <th>Exemples</th>
        <th>Mod√®le CAP</th>
        <th>Remarques</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Relationnel</td>
        <td>MySQL, PostgreSQL, Oracle, SQL Server, DB2</td>
        <td>CA</td>
        <td>Pas tol√©rant aux partitions ; mod√®le ACID classique</td>
      </tr>
      <tr>
        <td>Cl√©-Valeur</td>
        <td>Redis, Memcached, DynamoDB, CosmosDB</td>
        <td>AP<br>(DynamoDB configurable, CosmosDB PACELC)</td>
        <td>Redis peut √™tre CP avec Sentinel ; CosmosDB propose plusieurs niveaux de coh√©rence</td>
      </tr>
      <tr>
        <td>Colonne</td>
        <td>Cassandra, HBase, BigTable, Elasticsearch</td>
        <td>Cassandra : AP<br>HBase, BigTable : CP<br>Elasticsearch : AP</td>
        <td>Cassandra d√©riv√© de Dynamo ; HBase/BigTable visent la coh√©rence forte ; Elasticsearch tol√®re l‚Äôincoh√©rence</td>
      </tr>
      <tr>
        <td>Document</td>
        <td>MongoDB, Couchbase</td>
        <td>Mongo : CP (par d√©faut)<br>Couchbase : AP</td>
        <td>Mongo configurable via writeConcern/readConcern</td>
      </tr>
      <tr>
        <td>Graph</td>
        <td>Neo4J, OrientDB, FlockDB</td>
        <td>AP</td>
        <td>G√©n√©ralement utilis√©s en cluster limit√©, peu orient√©s partitionnement</td>
      </tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau positionne les bases selon leurs garanties CAP dominantes.  
    La colonne "Remarques" aide √† comprendre les compromis internes ou les capacit√©s de configuration avanc√©e (ex : CosmosDB, MongoDB).  
    Spark et SimpleDB ont √©t√© retir√©s pour clart√©.
  </aside>
</section>


<section>
  <h2>üóÉÔ∏è Bases de donn√©es et CAP</h2>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Base de donn√©es</th>
        <th>Profil CAP</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>Relationnel</td><td>MySQL, PostgreSQL, Oracle, SQL Server, DB2</td><td>CA</td></tr>
      <tr><td>Cl√©-Valeur</td><td>Redis, Memcached, SimpleDB, CosmosDB</td><td>AP (Redis), AP/CP (Memcached, SimpleDB, CosmosDB)</td></tr>
      <tr><td>Colonne</td><td>Elasticsearch, Apache Spark, HBase, BigTable</td><td>AP (Elastic, Spark), CP (HBase, BigTable)</td></tr>
      <tr><td>Document</td><td>MongoDB, DynamoDB, Couchbase, Cassandra</td><td>CP/AP (selon config)</td></tr>
      <tr><td>Graph</td><td>Neo4j, OrientDB, FlockDB</td><td>AP</td></tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau donne un aper√ßu des bases populaires et de leur alignement au mod√®le CAP.  
    ‚ö†Ô∏è Attention : certaines bases comme MongoDB ou Cassandra sont **configurables** et peuvent op√©rer soit en AP soit en CP selon le niveau de coh√©rence exig√© (readConcern/writeConcern, quorum...).
  </aside>
</section>

<section>
  <h2>üîß Usages typiques et CAP</h2>
  <ul>
    <li><strong>CA (bases relationnelles)</strong> :
      <ul>
        <li>ERP, gestion comptable, syst√®mes de facturation</li>
        <li>Utilis√©s l√† o√π la <strong>coh√©rence forte</strong> est cruciale</li>
      </ul>
    </li>
    <li><strong>AP (bases cl√©-valeur, colonne, document)</strong> :
      <ul>
        <li>Applications web globales, r√©seaux sociaux, moteurs de recommandation</li>
        <li>Favorisent la <strong>disponibilit√©</strong> et la <strong>latence faible</strong></li>
      </ul>
    </li>
    <li><strong>CP (bases colonne/document)</strong> :
      <ul>
        <li>Syst√®mes de messagerie, logs critiques, configuration distribu√©e</li>
        <li>La <strong>coh√©rence</strong> est maintenue m√™me au prix d‚Äôun blocage temporaire</li>
      </ul>
    </li>
    <li><strong>Graph (souvent AP)</strong> :
      <ul>
        <li>Analyse de r√©seaux sociaux, gestion de d√©pendances (ex: recommandations, cha√Ænes logistiques)</li>
        <li>Besoin de <strong>travers√©e rapide</strong> plut√¥t que coh√©rence forte</li>
      </ul>
    </li>
  </ul>
  <aside class="notes">
    Ces usages illustrent pourquoi toutes les bases ne se valent pas :  
    le choix d√©pend du m√©tier, du besoin de coh√©rence, de disponibilit√©, et des contraintes r√©seau.  
    CAP est un outil d‚Äôorientation, pas une r√®gle rigide.
  </aside>
</section>


<section>
  <h2>üîó Sources</h2>
  <ul>
    <li><a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank">Wikipedia ‚Äì CAP Theorem</a></li>
    <li><a href="https://code-garage.com/blog/comprendre-le-theoreme-cap" target="_blank">Comprendre le CAP theorem</a></li>
    <li><a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/" target="_blank">CAP Twelve Years Later (InfoQ)</a></li>
    <li><a href="https://aws.amazon.com/nosql/" target="_blank">AWS ‚Äì NoSQL et CAP</a></li>
  </ul>
  <aside class="notes">
    Ces ressources approfondissent les compromis concrets du CAP dans des cas industriels r√©els.
  </aside>
</section>

<section>
  <h2>Consistance √©ventuelle & Idempotence</h2>
  <ul>
    <li><strong>Consistance √©ventuelle</strong> : √©tat convergent √† terme</li>
    <li><strong>Idempotence</strong> : un appel r√©p√©t√© ne change pas le r√©sultat</li>
  </ul>
  <aside class="notes">
    Ces propri√©t√©s sont essentielles dans les architectures tol√©rantes aux pannes ou asynchrones.
  </aside>
</section>

<!-- section>
  <h2>üö´ Th√©or√®me de FLP</h2>
  <ul>
    <li>Dans un syst√®me distribu√© <strong>asynchrone</strong> o√π un processus peut √©chouer,</li>
    <li>Il est <strong>impossible</strong> de garantir qu‚Äôun protocole atteindra toujours un consensus,</li>
    <li>m√™me avec des canaux fiables.</li>
  </ul>
  <aside class="notes">
    Le th√©or√®me FLP (1985) montre que le consensus est impossible √† garantir dans un syst√®me totalement asynchrone avec pannes possibles.  
    Cela explique pourquoi les syst√®mes comme Paxos ou Raft sont complexes ou probabilistes.
  </aside>
</section -->

<!-- section>
  <h2>‚è± Th√©or√®me de Lamport</h2>
  <ul>
    <li>Pas d'horloge globale dans un syst√®me distribu√©</li>
    <li>Mais possibilit√© de d√©finir un <strong>ordre logique</strong> entre √©v√©nements</li>
    <li><code>A ‚Üí B</code> signifie que A se produit avant B</li>
  </ul>
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Lamport%27s_logical_clocks.svg/480px-Lamport%27s_logical_clocks.svg.png" alt="Lamport Clock" style="max-height: 250px;" />
  <aside class="notes">
    Dans un syst√®me distribu√©, il n‚Äôy a pas de temps universel.  
    L‚Äôalgorithme de Lamport attribue des timestamps logiques pour ordonner les √©v√©nements.  
    Base des CRDT, des syst√®mes √† journal distribu√©, etc.
  </aside>
</section -->

<section>
  <h2>‚öñÔ∏è Th√©or√®me PACELC</h2>
  <ul>
    <li>Compl√®te le CAP : si Partition, choix entre **Availability** ou **Consistency**</li>
    <li>Sinon (Else), choix entre **Latency** ou **Consistency**</li>
    <li>Formule : <strong>PACELC</strong> = <code>if P then A or C; else L or C</code></li>
  </ul>
  <aside class="notes">
    PACELC ajoute une dimension : m√™me sans partition, les bases doivent arbitrer entre latence et coh√©rence.  
    C‚Äôest un mod√®le plus r√©aliste pour les bases modernes comme DynamoDB ou CosmosDB.
  </aside>
</section>

<section>
  <h2>üß™ Exemples PACELC</h2>
  <ul>
    <li><strong>DynamoDB</strong> : PA/EL (disponible m√™me en partition, optimis√© pour latence)</li>
    <li><strong>BigTable</strong> : PC/EC (coh√©rence forte, quitte √† ralentir)</li>
    <li><strong>Cassandra</strong> : PA/EL (r√©plication et latence faible)</li>
  </ul>
  <aside class="notes">
    Dynamo et Cassandra privil√©gient la rapidit√© m√™me en cas d‚Äôincoh√©rence temporaire.  
    BigTable, au contraire, pr√©f√®re garantir des lectures coh√©rentes.  
    Le choix PACELC influence la conception applicative.
  </aside>
</section>

<!-- section>
  <h2>üìö Synth√®se p√©dagogique</h2>
  <table>
    <thead>
      <tr>
        <th>Th√©or√®me</th>
        <th>Pertinence p√©dagogique</th>
        <th>Int√©r√™t pratique</th>
        <th>Inclusion recommand√©e</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>FLP</td>
        <td>Moyenne</td>
        <td>Faible √† moyenne</td>
        <td>üåó 1 slide max, optionnel</td>
      </tr>
      <tr>
        <td>Lamport</td>
        <td>Haute</td>
        <td>Haute</td>
        <td>‚úÖ Oui, simple version</td>
      </tr>
      <tr>
        <td>PACELC</td>
        <td>Haute</td>
        <td>Haute</td>
        <td>‚úÖ Oui, compl√©ment CAP</td>
      </tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau aide √† d√©cider quels concepts approfondir ou simplement mentionner selon le temps, les objectifs et le niveau des √©tudiants.
  </aside>
</section -->

<section>
  <h2>üìã CAP vs PACELC</h2>
  <table>
    <thead>
      <tr><th>Mod√®le</th><th>Partition</th><th>Sans Partition</th><th>Avantage</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>CAP</strong></td>
        <td>Choix entre <strong>Availability</strong> ou <strong>Consistency</strong></td>
        <td>Non d√©fini</td>
        <td>Simple, fondamental</td>
      </tr>
      <tr>
        <td><strong>PACELC</strong></td>
        <td>Choix entre <strong>Availability</strong> ou <strong>Consistency</strong></td>
        <td>Choix entre <strong>Latency</strong> ou <strong>Consistency</strong></td>
        <td>Plus r√©aliste en pratique</td>
      </tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau montre que PACELC est une extension utile de CAP :  
    il ajoute la dimension de latence pour les cas sans partition, ce qui refl√®te mieux les compromis actuels dans les bases distribu√©es.
  </aside>
</section>

<section>
  <h2>‚öñÔ∏è ACID vs BASE</h2>
  <ul>
    <li><strong>ACID</strong> : mod√®le traditionnel pour bases relationnelles</li>
    <li><strong>BASE</strong> : approche plus souple, adapt√©e aux bases distribu√©es NoSQL</li>
  </ul>
  <aside class="notes">
    Ces deux mod√®les d√©finissent comment les syst√®mes g√®rent la coh√©rence et la fiabilit√© des transactions.  
    ACID est strict, BASE est tol√©rant : √† chaque besoin son mod√®le.
  </aside>
</section>

<section>
  <h2>üîí Mod√®le ACID</h2>
  <ul>
    <li><strong>Atomicity</strong> : tout ou rien</li>
    <li><strong>Consistency</strong> : √©tat valide avant/apr√®s la transaction</li>
    <li><strong>Isolation</strong> : pas d'interf√©rence entre transactions</li>
    <li><strong>Durability</strong> : une fois valid√©e, la transaction est persist√©e</li>
  </ul>
  <aside class="notes">
    ACID est con√ßu pour la fiabilit√© : tr√®s utile pour les syst√®mes critiques comme la banque, la facturation.  
    Il s'appuie sur un contr√¥le transactionnel fort.
  </aside>
</section>

<section>
  <h2>ACID ‚Äì Avantages et limites</h2>
  <ul>
    <li><strong>‚úÖ Avantages :</strong> s√©curit√© des donn√©es, coh√©rence garantie</li>
    <li><strong>‚ö†Ô∏è Inconv√©nients :</strong> faible scalabilit√©, complexit√© en distribution</li>
    <li><strong>üìå Bases concern√©es :</strong> MySQL, PostgreSQL, Oracle, SQLite</li>
  </ul>
  <aside class="notes">
    Les bases ACID excellent sur un seul n≈ìud, mais se complexifient fortement en environnement distribu√©.  
    Elles sont n√©anmoins indispensables dans des cas comme les paiements ou l‚ÄôERP.
  </aside>
</section>

<section>
  <h2>üåä Mod√®le BASE</h2>
  <ul>
    <li><strong>Basically Available</strong> : le syst√®me r√©pond toujours, m√™me partiellement</li>
    <li><strong>Soft state</strong> : l‚Äô√©tat peut changer sans nouvelle √©criture</li>
    <li><strong>Eventual consistency</strong> : la coh√©rence est atteinte √† terme</li>
  </ul>
  <aside class="notes">
    BASE est une approche plus souple, pens√©e pour les syst√®mes distribu√©s massivement parall√®les.  
    Elle accepte des incoh√©rences temporaires pour garantir disponibilit√© et scalabilit√©.
  </aside>
</section>

<section>
  <h2>BASE ‚Äì Avantages et limites</h2>
  <ul>
    <li><strong>‚úÖ Avantages :</strong> haute disponibilit√©, performance, tol√©rance r√©seau</li>
    <li><strong>‚ö†Ô∏è Inconv√©nients :</strong> incoh√©rences temporaires, gestion des conflits</li>
    <li><strong>üìå Bases concern√©es :</strong> Cassandra, DynamoDB, CouchDB, Riak</li>
  </ul>
  <aside class="notes">
    Les bases BASE sont adapt√©es √† des syst√®mes globalement distribu√©s, √† forte volum√©trie : r√©seaux sociaux, logs, IoT, etc.  
    La coh√©rence √©ventuelle demande une logique applicative robuste.
  </aside>
</section>

<section>
  <h2>üìä ACID vs BASE</h2>
  <table>
    <thead><tr><th>Propri√©t√©</th><th>ACID</th><th>BASE</th></tr></thead>
    <tbody>
      <tr><td>Disponibilit√©</td><td>Secondaire</td><td>Prioritaire</td></tr>
      <tr><td>Coh√©rence</td><td>Forte</td><td>√âventuelle</td></tr>
      <tr><td>Partition tolerance</td><td>Faible</td><td>Essentielle</td></tr>
      <tr><td>Performance</td><td>Stable</td><td>Optimis√©e</td></tr>
      <tr><td>Cas typique</td><td>Bancaire, ERP</td><td>Web, Big Data</td></tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau aide √† choisir la bonne approche selon le contexte m√©tier.  
    ACID = rigueur, BASE = scalabilit√©. Le choix n‚Äôest pas technique, il est fonctionnel.
  </aside>
</section>

<section>
  <h2>üîó Sources</h2>
  <ul>
    <li><a href="https://en.wikipedia.org/wiki/ACID" target="_blank">Wikipedia ‚Äì ACID</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Eventual_consistency" target="_blank">Wikipedia ‚Äì Eventual Consistency</a></li>
    <li><a href="https://www.infoq.com/articles/base-an-acid-alternative/" target="_blank">InfoQ ‚Äì BASE: An ACID Alternative</a></li>
    <li><a href="https://martinfowler.com/articles/nosql-intro.html" target="_blank">Martin Fowler ‚Äì NoSQL Intro</a></li>
  </ul>
  <aside class="notes">
    Vous pouvez approfondir la th√©orie et les cas pratiques de BASE et ACID √† travers ces articles.  
    Martin Fowler donne aussi un bon aper√ßu des implications dans les architectures NoSQL.
  </aside>
</section>


<!-- === SECTION 2 : Architecture et Design === -->
<section>
  <h2>üß© Architecture et Design</h2>
  <aside class="notes">
    Ces patterns aident √† structurer votre code et votre base de donn√©es autour de la logique m√©tier, tout en favorisant l‚Äôind√©pendance des services.
  </aside>
</section>

<section>
  <h2>Domain Driven Design (DDD)</h2>
  <ul>
    <li>Ubiquitous Language, Bounded Context</li>
    <li>Entities, Value Objects, Aggregates</li>
    <li>Domain Services, Domain Events, Repositories</li>
  </ul>
  <aside class="notes">
    La DDD permet de faire correspondre la structure du code √† celle du m√©tier. On isole les responsabilit√©s m√©tier dans des contextes bien d√©limit√©s.
  </aside>
</section>

<section>
  <h2>Database per Domain</h2>
  <ul>
    <li>Chaque service a sa propre base</li>
    <li>Pas de couplage via la base de donn√©es</li>
  </ul>
  <aside class="notes">
    Cela permet une ind√©pendance de d√©ploiement, et √©vite les verrouillages entre √©quipes ou modules.
  </aside>
</section>

<section>
  <h2>CQRS & Event Sourcing</h2>
  <ul>
    <li><strong>CQRS</strong> : s√©paration √©criture/lecture</li>
    <li><strong>Event Sourcing</strong> : reconstruction via les √©v√©nements</li>
  </ul>
  <aside class="notes">
    Ces patterns apportent tra√ßabilit√© et performance, mais compliquent le mod√®le conceptuel.
  </aside>
</section>

<section>
  <h2>Saga Pattern</h2>
  <ul>
    <li><strong>Choreography</strong> : r√©action en cha√Æne sans chef d‚Äôorchestre</li>
    <li><strong>Orchestration</strong> : coordination centralis√©e</li>
  </ul>
  <aside class="notes">
    Permet de g√©rer des transactions longues et distribu√©es sans rollback global.
  </aside>
</section>

<section>
  <h2>Couplage faible</h2>
  <ul>
    <li>Isolation des services</li>
    <li>Utilisation d‚Äô√©v√©nements ou d‚ÄôAPI explicites</li>
  </ul>
  <aside class="notes">
    Un service doit pouvoir √©voluer ou tomber sans mettre √† mal les autres.
  </aside>
</section>

<!-- === SECTION 3 : R√©silience & Scalabilit√© === -->
<section>
  <h2>üõ°Ô∏è R√©silience et Scalabilit√©</h2>
  <aside class="notes">
    Objectif : garantir le bon fonctionnement, m√™me en cas de panne ou de mont√©e en charge.
  </aside>
</section>

<section>
  <h2>Scalabilit√©</h2>
  <ul>
    <li>Verticale / Horizontale / √âlastique</li>
    <li>Auto-scaling, Load balancing, Sharding</li>
  </ul>
  <aside class="notes">
    Scalabilit√© = capacit√© √† cro√Ætre avec la demande. On vise souvent une architecture "cloud-native".
  </aside>
</section>

<section>
  <h2>R√©silience</h2>
  <ul>
    <li>Circuit Breaker, Retry, Timeout</li>
    <li>Graceful Degradation, Self-Healing</li>
  </ul>
  <aside class="notes">
    La r√©silience est essentielle dans des environnements instables ou √† forte latence.
  </aside>
</section>

<!-- === SECTION 4 : Testabilit√© & Observabilit√© === -->
<section>
  <h2>üß™ Testabilit√© et Observabilit√©</h2>
  <aside class="notes">
    Ces dimensions garantissent la qualit√© et la compr√©hension du syst√®me dans la dur√©e.
  </aside>
</section>

<section>
  <h2>Testabilit√©</h2>
  <ul>
    <li>Unit, Integration, Contract, E2E tests</li>
    <li>Performance, Chaos engineering</li>
  </ul>
  <aside class="notes">
    Les tests contractuels sont particuli√®rement importants dans les syst√®mes distribu√©s.
  </aside>
</section>

<section>
  <h2>Observabilit√©</h2>
  <ul>
    <li>Logging, Metrics, Tracing</li>
    <li>Monitoring, Alerting</li>
  </ul>
  <aside class="notes">
    Sans observabilit√©, on ne comprend pas ce qui se passe, on subit.
  </aside>
</section>

<!-- === SECTION 5 : Gouvernance & √âquipes === -->
<section>
  <h2>üß† Gouvernance et √âquipes</h2>
  <aside class="notes">
    Un bon syst√®me distribu√© d√©pend aussi de l'organisation des √©quipes et de leur capacit√© √† livrer vite.
  </aside>
</section>

<section>
  <h2>DORA Metrics</h2>
  <ul>
    <li>Lead Time for Changes</li>
    <li>Deployment Frequency</li>
    <li>Time to Restore Service</li>
    <li>Change Failure Rate</li>
  </ul>
  <aside class="notes">
    Ces m√©triques permettent de piloter les performances DevOps de mani√®re objective.
  </aside>
</section>

<section>
  <h2>Team Topologies</h2>
  <ul>
    <li>Stream-aligned, Enabling, Platform, Complicated Subsystem</li>
    <li>Interactions : X-as-a-Service, Collaboration, Facilitation</li>
  </ul>
  <aside class="notes">
    Ce mod√®le aide √† organiser les √©quipes pour refl√©ter les objectifs de l‚Äôarchitecture logicielle.
  </aside>
</section>

<!-- Slide de conclusion -->
<section>
  <h2>Conclusion</h2>
  <ul>
    <li>Architecture = √©quilibre entre m√©tier, technologie et organisation</li>
    <li>Ces concepts sont vos briques de construction</li>
    <li>Adaptez-les √† vos cas d‚Äôusage</li>
  </ul>
  <aside class="notes">
    L‚Äôobjectif n‚Äôest pas de tout appliquer, mais de faire les bons choix pour chaque projet.
  </aside>
</section>
