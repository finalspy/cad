<!-- Sommaire -->
<section>
  <h2>ğŸ—‚ï¸ Sommaire</h2>
  <ul>
    <li>ğŸ“– Partie 1 : ThÃ©orie DDD
      <ul>
        <li>ğŸ¯ Pourquoi DDD ?</li>
        <li>ğŸ§­ Concepts stratÃ©giques</li>
        <li>ğŸ› ï¸ Concepts tactiques</li>
      </ul>
    </li>
    <li>ğŸš€ Partie 2 : Pratique VibeReveal
      <ul>
        <li>ğŸ“‹ Cartographie du monolithe</li>
        <li>ğŸ—ï¸ Extraction du Domain Model</li>
        <li>ğŸ”§ Refactoring PresentationService</li>
        <li>ğŸ’¾ Repositories</li>
        <li>ğŸ›ï¸ Application Services</li>
        <li>ğŸ”„ Event Bus</li>
      </ul>
    </li>
    <li>âœ… Conclusion</li>
    <li>ğŸ“š Ressources</li>
    <li>â“ Quiz</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>PrÃ©sentation du plan : thÃ©orie d'abord, puis application sur VibeReveal.</li>
      <li>Chaque partie comporte plusieurs Ã©tapes clairement marquÃ©es.</li>
    </ul>
  </aside>
</section>

<!-- Transition vers Partie 1 -->
<section>
  <h2>ğŸ“– Partie 1 : ThÃ©orie DDD</h2>
  <p>Comprendre les concepts clÃ©s pour modÃ©liser un domaine riche.</p>
  <aside class="notes">
    <ul>
      <li>Objectif : donner un langage commun et des rÃ¨gles d'organisation au code.</li>
    </ul>
  </aside>
</section>

<!-- Pourquoi DDD -->
<section>
  <h2>ğŸ¯ Pourquoi DDD ?</h2>
  <ul>
    <li>Aligner le code sur le cÅ“ur mÃ©tier pour rester pertinent.</li>
    <li>RÃ©duire les malentendus avec un vocabulaire unique.</li>
    <li>Faciliter la maintenance et l'Ã©volution du logiciel.</li>
    <li>GÃ©rer la complexitÃ© dans les systÃ¨mes distribuÃ©s.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Sans DDD, chaque Ã©quipe peut appeler la mÃªme chose diffÃ©remment.</li>
      <li>Expliquer : 40â€¯% des retards proviennent de ce manque d'alignement.</li>
    </ul>
  </aside>
</section>

<!-- Ubiquitous Language -->
<section>
  <h2>ğŸ§­ Ubiquitous Language</h2>
  <ul>
    <li>CrÃ©er un dictionnaire commun de termes mÃ©tier (ex : Presentation, Slide).</li>
    <li>Utiliser ces termes partout : code, docs, discussions.</li>
    <li>Ã‰viter tout synonyme pour un mÃªme concept.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Exemple : Â« Slide Â» dÃ©signe toujours une diapositive, jamais un composant UI.</li>
      <li>Maintenir ce glossaire Ã  jour en revue de code.</li>
    </ul>
  </aside>
</section>

<!-- Bounded Context -->
<section>
  <h2>ğŸ”’ Bounded Context</h2>
  <ul>
    <li>DÃ©limiter des zones oÃ¹ un modÃ¨le est cohÃ©rent.</li>
    <li>Chaque contexte a son propre langage et ses entitÃ©s.</li>
    <li>Communiquer entre contextes via contrats (API, events, adapters).</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Exemples : EditingContext pour la crÃ©ation, PublishingContext pour l'export.</li>
      <li>PrÃ©venir le couplage fort avec un Anti-Corruption Layer.</li>
    </ul>
  </aside>
</section>

<!-- Context Mapping -->
<section>
  <h2>ğŸ—ºï¸ Context Mapping</h2>
  <div class="mermaid">
    graph LR
      EditingCtx["EditingContext"]
      PublishingCtx["PublishingContext"]
      Auth["AuthService"]
      Analytics["AnalyticsService"]
      EditingCtx -->|"valide user"| Auth
      EditingCtx -->|"crÃ©Ã©"| PublishingCtx
      PublishingCtx -->|"notifie"| Analytics
  </div>
  <aside class="notes">
    <ul>
      <li>Montrer les flux d'informations et les patterns de relation.</li>
      <li>Expliquer l'utilitÃ© d'un contexte partagÃ© ou d'un ACL.</li>
    </ul>
  </aside>
</section>

<!-- Transition vers Partie 1 tactique -->
<section>
  <h2>ğŸ› ï¸ Partie 1 : Concepts Tactiques</h2>
  <p>Les rÃ¨gles de construction dans le code.</p>
  <aside class="notes">
    <ul>
      <li>Les building blocks DDD appliquÃ©s en TypeScript.</li>
    </ul>
  </aside>
</section>

<!-- Entity -->
<section>
  <h2>ğŸ·ï¸ Entity</h2>
  <ul>
    <li>Objet avec identitÃ© unique (ID).</li>
    <li>Cicatrice : peut Ã©voluer, mais reste toujours le mÃªme.</li>
    <li>Cycle de vie : crÃ©ation â†’ modification â†’ suppression.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Ex : Slide a toujours le mÃªme ID mÃªme si son contenu change.</li>
    </ul>
  </aside>
</section>

<!-- Value Object -->
<section>
  <h2>ğŸ¨ Value Object</h2>
  <ul>
    <li>Immuable : pas de modification, on crÃ©e de nouvelles instances.</li>
    <li>Ã‰galitÃ© par valeur : mÃªmes attributs â†’ mÃ©me objet conceptuel.</li>
    <li>Pas d'ID ; dÃ©finit un concept (ex : SlideContent).</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>SlideContent contient texte et imageUrl, et ne change jamais.</li>
    </ul>
  </aside>
</section>

<!-- Example Entity vs VO -->
<section>
  <h2>ğŸ“¦ Exemple : Slide & SlideContent</h2>
  <pre><code class="language-ts">class SlideContent { constructor(text: string) { /* ... */ } }
class Slide { constructor(id: string, content: SlideContent) { /* ... */ } }
</code></pre>
  <aside class="notes">
    <ul>
      <li>SlideContent partagÃ© entre plusieurs Slides.</li>
      <li>Chaque Slide garde son ID unique.</li>
    </ul>
  </aside>
</section>

<!-- Aggregate -->
<section>
  <h2>ğŸŒ³ Aggregate</h2>
  <ul>
    <li>Groupe cohÃ©rent d'entities et de VOs.</li>
    <li>Aggregate Root (ex : Presentation) contrÃ´le l'accÃ¨s.</li>
    <li>Transactional boundary : tout ou rien.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>PrÃ©sentation agit comme la seule porte d'entrÃ©e pour ses Slides.</li>
    </ul>
  </aside>
</section>

<!-- Example Aggregate -->
<section>
  <h2>ğŸ“‹ Exemple : Presentation</h2>
  <pre><code class="language-ts">class Presentation { /* ... */ }
const pres = new Presentation('p1');
pres.addSlide(new SlideContent('Hi')); 
</code></pre>
  <aside class="notes">
    <ul>
      <li>Chaque ajout de slide doit passer par la racine d'agrÃ©gat.</li>
    </ul>
  </aside>
</section>

<!-- Domain Service -->
<section>
  <h2>âš™ï¸ Domain Service</h2>
  <ul>
    <li>Logique mÃ©tier transcendant plusieurs agrÃ©gats.</li>
    <li>Ex : calcul de statistiques sur plusieurs Presentations.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Ne stocke pas de donnÃ©es, n'appartient Ã  aucune entitÃ©.</li>
    </ul>
  </aside>
</section>

<!-- Factory -->
<section>
  <h2>ğŸ­ Factory</h2>
  <ul>
    <li>Produit des agrÃ©gats en garantissant des invariants.</li>
    <li>Ex : crÃ©ation d'une Presentation avec une slide d'accueil.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Placez la logique de construction complexe ici.</li>
    </ul>
  </aside>
</section>

<!-- Repository -->
<section>
  <h2>ğŸ’¾ Repository</h2>
  <ul>
    <li>Abstraction de la persistence des agrÃ©gats.</li>
    <li>Ex : interface pour MongoDB ou In-Memory.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Ne contient pas de logique mÃ©tier, juste CRUD et requÃªtes simples.</li>
    </ul>
  </aside>
</section>

<!-- Domain Event -->
<section data-transition="fade">
  <h3>ğŸ”” Domain Event</h3>
  <ul>
    <li>Message immuable signalant un changement mÃ©tier.</li>
    <li>DÃ©clencheur d'actions asynchrones.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Ex : <code>SlideAddedEvent</code> pour lancer l'export Reveal.js.</li>
    </ul>
  </aside>
</section>

<!-- Mermaid sequence diagram -->
<section data-transition="fade">
  <h2>ğŸ”„ SÃ©quence : Export Reveal.js</h2>
  <div class="mermaid">
    sequenceDiagram
      participant U as User
      participant C as Controller
      participant A as AppService
      participant D as DomainService
      participant R as Repository
      participant E as EventBus
      participant P as PublishingCtx
      U->>C: POST /export
      C->>A: createExport(dto)
      A->>D: exportPresentation(id)
      D->>R: findById(id)
      R-->>D: Presentation
      D->>E: publish(SlideAddedEvent)
      E->>P: handleExport
      P->>P: generateRevealBundle
      P-->>U: return bundle
  </div>
  <aside class="notes">
    <ul>
      <li>Montrer la chaÃ®ne du HTTP jusqu'au bundle Reveal.js.</li>
      <li>Mettre en Ã©vidence la sÃ©paration des responsabilitÃ©s Ã  chaque Ã©tape.</li>
    </ul>
  </aside>
</section>

<!-- Transition vers Partie 2 -->
<section>
  <h2>ğŸš€ Partie 2 : Pratique VibeReveal</h2>
  <p>Refactoring pas-Ã -pas de votre monolithe vers DDD.</p>
  <aside class="notes">
    <ul>
      <li>Nous allons partir de votre code existant et le restructurer.</li>
    </ul>
  </aside>
</section>

<!-- PARTIE 2 Pratique -->
<section>
  <h2>ğŸ“‹ Cartographie du monolithe actuel</h2>
  <pre><code>// Structure du monolithe VibeReveal existant
src/
â”œâ”€ controllers/
â”œâ”€ services/
â”‚  â”” presentationService.js
â”œâ”€ routes/
â”œâ”€ models/
â”œâ”€ public/
â”‚  â”œ js/
â”‚  â”” css/
â””â”€ utils/
</code></pre>
  <aside class="notes">
    <ul>
      <li>Identifier les modules actuels et leur responsabilitÃ©.</li>
      <li>RepÃ©rer les couches mÃ©langeant logique mÃ©tier, API et persistence.</li>
    </ul>
  </aside>
</section>


<section>
  <h2>ğŸ—ï¸ Extraction du Domain Model</h2>
  <pre><code>// CrÃ©er un dossier domain/ avec :
// domain/entities/Presentation.ts
// domain/entities/Slide.ts
// domain/valueObjects/SlideContent.ts
</code></pre>
  <aside class="notes">
    <ul>
      <li>Isoler les classes mÃ©tier du reste du code.</li>
      <li>Conserver uniquement les attributs et rÃ¨gles mÃ©tier.</li>
    </ul>
  </aside>
</section>
<section>
  <h2>ğŸ”§ Refactoring de PresentationService</h2>
  <pre><code>// Avant: presentationService.js
function createPresentation(data) { /* mÃ©lange validation, persistence */ }

// AprÃ¨s: domain/services/PresentationService.ts
class PresentationService {
  constructor(
    private readonly repo: PresentationRepository
  ) {}
  create(data: CreatePresentationDto) {
    const pres = PresentationFactory.create(data.id, data.title);
    return this.repo.save(pres);
  }
}
</code></pre>
  <aside class="notes">
    <ul>
      <li>SÃ©parer la validation mÃ©tier, la crÃ©ation de l'agrÃ©gat et la persistence.</li>
      <li>Utiliser PresentationFactory pour construire l'entitÃ©.</li>
    </ul>
  </aside>
</section>
<section>
  <h2>ğŸ’¾ Mise en place de Repository</h2>
  <pre><code>// infra/repositories/MongoPresentationRepository.ts
class MongoPresentationRepository implements PresentationRepository {
  async save(pres: Presentation): Promise<void> {
    await mongoClient.collection('presentations')
      .insertOne(pres);
  }
  async findById(id: string) {
    const doc = await mongoClient
      .collection('presentations')
      .findOne({ id });
    return doc ? Presentation.from(doc) : null;
  }
}
</code></pre>
  <aside class="notes">
    <ul>
      <li>Encapsuler l'accÃ¨s Ã  MongoDB derriÃ¨re une interface.</li>
      <li>PrÃ©server le Domain Model indÃ©pendant de la persistence.</li>
    </ul>
  </aside>
</section>
<section>
  <h2>ğŸ›ï¸ Conversion des Controllers en Application Services</h2>
  <pre><code>// routes/presentationRoutes.ts
router.post('/presentations', async (req, res) => {
  const result = await presentationService.create(req.body);
  res.json(result);
});

// application/PresentationAppService.ts
class PresentationAppService {
  constructor(private svc: PresentationService) {}
  async createPresentation(dto: any) {
    return this.svc.create(dto);
  }
}
</code></pre>
  <aside class="notes">
    <ul>
      <li>Utiliser un adapter pour convertir DTO HTTP en DTO mÃ©tier.</li>
      <li>Gardez les controllers fins (thin controllers).</li>
    </ul>
  </aside>
</section>
<section>
  <h2>ğŸ”„ Publication d'Ã©vÃ©nements et intÃ©gration Event Bus</h2>
  <pre><code>// domain/events/PresentationCreated.ts
class PresentationCreated {
  constructor(
    public readonly id: string,
    public readonly timestamp = new Date()
  ){}
}

// AprÃ¨s save dans PresentationService:
this.repo.save(pres);
eventBus.publish(new PresentationCreated(pres.id));
</code></pre>
  <aside class="notes">
    <ul>
      <li>Publier un event Ã  chaque changement critique.</li>
      <li>DÃ©charger l'export Reveal.js dans un consumer asynchrone.</li>
    </ul>
  </aside>
</section>

<!-- Erreurs courantes Ã  Ã©viter -->
<section>
  <h2>âŒ Erreurs courantes Ã  Ã©viter</h2>
  <ul>
    <li>Anemic Domain Model : logique mÃ©tier dans les services, pas dans les entitÃ©s.</li>
    <li>AgrÃ©gats trop gros (> 5-7 objets) : complexitÃ© et verrous.</li>
    <li>Transactions distribuÃ©es entre agrÃ©gats : risque de deadlocks.</li>
    <li>RÃ©fÃ©rences directes entre bounded contexts : couplage fort.</li>
    <li>Repository qui fuit la logique mÃ©tier : mÃ©thodes trop spÃ©cifiques.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>L'Anemic Domain Model conduit Ã  du code procÃ©dural, perdant l'encapsulation.</li>
      <li>AgrÃ©gats trop volumineux dÃ©gradent performances (+40-60%) et maintenabilitÃ©.</li>
      <li>PrivilÃ©gier la cohÃ©rence Ã©ventuelle via Domain Events plutÃ´t que transactions cross-agrÃ©gat.</li>
      <li>Communiquer entre contexts via Ã©vÃ©nements ou ACL, jamais par rÃ©fÃ©rences directes.</li>
      <li>Utiliser le pattern Specification plutÃ´t que des mÃ©thodes reposant sur la logique mÃ©tier.</li>
    </ul>
  </aside>
</section>

<!-- Bonnes pratiques -->
<section>
  <h2>âœ… Bonnes pratiques</h2>
  <ul>
    <li>Commencer petit : un seul bounded context Ã  la fois.</li>
    <li>ModÃ©lisation stratÃ©gique avant d'Ã©crire du code (Event Storming, Context Mapping).</li>
    <li>Tester le domaine en prioritÃ© : tests unitaires sur agrÃ©gats et services.</li>
    <li>Maintenir le langage omniprÃ©sent : vÃ©rifier en revue de code.</li>
    <li>Ã‰viter la sur-ingÃ©nierie : DDD pour domaines complexes, pas CRUD simples.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Investir 20% du temps en ateliers de modÃ©lisation avant dÃ©veloppement.</li>
      <li>Visez 90%+ de couverture de tests sur le domaine.</li>
      <li>Validez le vocabulaire en code review pour Ã©viter la dette technique.</li>
      <li>Appliquer DDD progressivement, en pilotant un contexte critique en premier.</li>
    </ul>
  </aside>
</section>

<section>
  <h2>âœ… Conclusion</h2>
  <ul>
    <li>Le DDD amÃ©liore la qualitÃ© et la maintenabilitÃ© de VibeReveal.</li>
    <li>Patrons avancÃ©s : CQRS, Event Sourcing, Hexagonal Architecture.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Partager les rÃ©fÃ©rences pour approfondir chaque pattern.</li>
      <li>Encourager les Ã©changes au sein de la formation.</li>
    </ul>
  </aside>
</section>

<section>
  <h2>ğŸ“š Ressources</h2>
  <ul>
    <li>Domain-Driven Design : livre par Eric Evans</li>
    <li>Implementing Domain-Driven Design : Vaughn Vernon</li>
    <li><a href="https://www.domainlanguage.com/ddd/">domainlanguage.com/ddd</a></li>
    <li><a href="https://martinfowler.com/bliki/BoundedContext.html">martinfowler.com - Bounded Context</a></li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Proposer des lectures pour approfondir chaque concept DDD.</li>
      <li>Inviter Ã  rejoindre la communautÃ© DDD pour Ã©changer des retours.</li>
    </ul>
  </aside>
</section>

<section>
  <h2>â“ Quiz Interactif</h2>
</section>
<section
  <ul>
    <li>1. Qu'est-ce qu'un Value Object ?
      <ul>
        <li>A) Un objet avec une identitÃ© unique</li>
        <li>B) Un objet immuable dÃ©fini par ses attributs</li>
        <li>C) Un service applicatif</li>
        <li>D) Un Ã©vÃ©nement mÃ©tier</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <ul>
    <li>2. Quel est le rÃ´le de l'Aggregate Root ?
      <ul>
        <li>A) ContrÃ´ler la consistance de l'agrÃ©gat</li>
        <li>B) Publier des Ã©vÃ©nements</li>
        <li>C) GÃ©rer directement la persistance</li>
        <li>D) DÃ©finir l'interface utilisateur</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <ul>
    <li>3. Ã€ quoi sert un Domain Service ?
      <ul>
        <li>A) Stocker les donnÃ©es</li>
        <li>B) Orchestrer la logique mÃ©tier sans appartenir Ã  une entitÃ©</li>
        <li>C) Convertir les DTO HTTP</li>
        <li>D) GÃ©nÃ©rer des vues</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <ul>
    <li>4. Qu'est-ce qu'un Repository ?
      <ul>
        <li>A) Un objet mÃ©tier</li>
        <li>B) Une interface de persistance pour les agrÃ©gats</li>
        <li>C) Un service d'export Reveal.js</li>
        <li>D) Une factory</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <ul>
    <li>5. Quel pattern protÃ¨ge un contexte d'influence externe ?
      <ul>
        <li>A) Shared Kernel</li>
        <li>B) Anti-Corruption Layer</li>
        <li>C) Conformist</li>
        <li>D) Partnership</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <ul>
    <li>6. Qu'est-ce qu'un Domain Event ?
      <ul>
        <li>A) Un objet immuable signalant un changement mÃ©tier</li>
        <li>B) Une entitÃ© avec identitÃ©</li>
        <li>C) Un Value Object</li>
        <li>D) Un service mÃ©tier</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <ul>
    <li>7. Pourquoi utiliser un Ubiquitous Language ?
      <ul>
        <li>A) Pour rÃ©duire la duplication de code</li>
        <li>B) Pour aligner la communication entre mÃ©tiers et technique</li>
        <li>C) Pour cacher la logique mÃ©tier</li>
        <li>D) Pour amÃ©liorer la performance</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <ul>
    <li>8. Qu'est-ce qu'une Context Map ?
      <ul>
        <li>A) Liste de tous les modules</li>
        <li>B) Diagramme des relations entre bounded contexts</li>
        <li>C) Graphique de performance</li>
        <li>D) Catalogue de services</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <ul>
    <li>9. Quelle est la Transactional Boundary ?
      <ul>
        <li>A) La limite d'un service HTTP</li>
        <li>B) La limite au sein de l'agrÃ©gat oÃ¹ la cohÃ©rence est garantie</li>
        <li>C) Un service de domaine</li>
        <li>D) Un Ã©vÃ©nement mÃ©tier</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <ul>
    <li>10. Quel pattern permet l'autonomie des Ã©quipes en limitant les dÃ©pendances ?
      <ul>
        <li>A) Conformist</li>
        <li>B) Customer-Supplier</li>
        <li>C) Anti-Corruption Layer</li>
        <li>D) Shared Kernel</li>
      </ul>
    </li>
  </ul>
</ul>
</section>
<section>
  <aside class="notes">
    <ul>
      <li>Proposer un quiz interactif pour valider les connaissances.</li>
    </ul>
  <p><strong>RÃ©ponses correctes :</strong> 1:B, 2:A, 3:B, 4:B, 5:B, 6:A, 7:B, 8:B, 9:B, 10:B</p>
  </aside>
</section>

<section>
  <h2>ğŸ“ˆ Avantages & InconvÃ©nients de l'Architecture DistribuÃ©e</h2>
  <ul>
    <li><strong>Avantages :</strong>
      <ul>
        <li>ScalabilitÃ© indÃ©pendante des services.</li>
        <li>RÃ©silience accrue grÃ¢ce Ã  la dÃ©centralisation.</li>
        <li>Ã‰volution autonome des bounded contexts.</li>
      </ul>
    </li>
    <li><strong>InconvÃ©nients :</strong>
      <ul>
        <li>ComplexitÃ© de gestion des transactions distribuÃ©es.</li>
        <li>Latence et surcharge rÃ©seau plus importantes.</li>
        <li>ComplexitÃ© accrue du monitoring et du debugging.</li>
      </ul>
    </li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Souligner l'impact sur l'organisation : nÃ©cessite des compÃ©tences DevOps et surveillance.</li>
      <li>Montrer que la modÃ©lisation DDD facilite le dÃ©coupage distribuÃ©.</li>
    </ul>
  </aside>
</section>

<section>
  <h2>ğŸš€ Ã‰tapes suivantes</h2>
  <ul>
    <li>1ï¸âƒ£ ImplÃ©menter CQRS pour sÃ©parer lecture et Ã©criture.</li>
    <li>2ï¸âƒ£ Introduire l'Event Sourcing pour historiser les changements.</li>
    <li>3ï¸âƒ£ Adopter l'architecture hexagonale (ports & adapters).</li>
    <li>4ï¸âƒ£ Mettre en place des tests d'intÃ©gration et des contrats.</li>
    <li>5ï¸âƒ£ Automatiser le dÃ©ploiement continu pour chaque contexte.</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Proposer un atelier de 2 h sur CQRS et Event Sourcing.</li>
      <li>Planifier un pilote sur un bounded context de VibeReveal.</li>
    </ul>
  </aside>
</section>
