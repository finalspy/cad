<!-- Slide d'introduction g√©n√©rale -->
<section data-background-image="/public/images/titre_concepts.jpg" 
          data-background-size="cover"
          data-background-opacity="0.5">
  <h1>Concepts cl√©s</h1>
  <ul>
    <li><b>üî∫ Th√©or√®mes fondamentaux</b></li>
    <li>üß© Architecture et Design</li>
    <li>üõ°Ô∏è R√©silience et Scalabilit√©</li>
    <li>üß™ Tests et Observabilit√©</li>
    <li>üß† Gouvernance et √âquipes</li>
  </ul>
</section>

<!-- === SECTION 1 : Th√©or√®mes fondamentaux === -->
<section>
  <h2>üî∫ Th√©or√®mes fondamentaux</h2>
  <ul>
    <li>Th√©or√®me de Brewer (CAP)</li>
    <li>ACID / BASE</li>
    <!--li>Th√©or√®me de FLP</li>
    <li>Th√©or√®me de Lamport</li>
    <li>Th√©or√®me de PACELC</li-->
  </ul>
  <aside class="notes">
    Ces th√©or√®mes posent les limites th√©oriques des syst√®mes distribu√©s. Ils influencent tous les choix techniques ult√©rieurs.
  </aside>
</section>

<section>
  <h2>CAP Theorem</h2>
  <ul>
    <li><strong>Consistency</strong>: m√™me valeur pour tous les n≈ìuds</li>
    <li><strong>Availability</strong>: r√©ponse √† chaque requ√™te</li>
    <li><strong>Partition Tolerance</strong>: robustesse en cas de rupture r√©seau</li>
  </ul>
  <aside class="notes">
    Dans un syst√®me distribu√©, on ne peut garantir les trois √† la fois. CAP nous oblige √† faire des compromis.
  </aside>
</section>

<section>
  <h2>CAP Theorem</h2>
  <!-- img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/CAP_theorem.svg/500px-CAP_theorem.svg.png" alt="Diagramme CAP" style="max-height: 400px;" /-->
  <img src="/public/schemas/cap.jpg" alt="Diagramme CAP" style="max-height: 400px;" />
  <aside class="notes">
    Le th√©or√®me CAP (Brewer, 2000) dit qu'un syst√®me distribu√© ne peut garantir simultan√©ment Coh√©rence, Disponibilit√© et Tol√©rance au partitionnement.  
    Il faut choisir deux propri√©t√©s selon le besoin.
  </aside>
</section>

<section>
  <h2>Les 3 propri√©t√©s CAP</h2>
  <ul>
    <li><strong>C</strong> - Consistency : Tous les n≈ìuds voient les m√™mes donn√©es en m√™me temps.</li>
    <li><strong>A</strong> - Availability : Chaque requ√™te re√ßoit une r√©ponse, m√™me en cas de panne.</li>
    <li><strong>P</strong> - Partition Tolerance : Le syst√®me continue √† fonctionner malgr√© des d√©faillances r√©seau.</li>
  </ul>
  <aside class="notes">
    Lorsqu'une partition r√©seau survient, vous devez sacrifier soit la coh√©rence soit la disponibilit√©. Ce choix d√©pend du cas d'usage.
  </aside>
</section>

<section>
  <h2>üîµ CA : Consistency + Availability</h2>
  <ul>
    <li><strong>Avantages :</strong> r√©ponses coh√©rentes et toujours disponibles tant que le r√©seau est fiable</li>
    <li><strong>Inconv√©nients :</strong> si une partition survient, le syst√®me devient indisponible</li>
    <li><strong>Cas d'usage :</strong> syst√®mes en cluster local (pas r√©partis sur Internet)</li>
    <li><strong>Bases de donn√©es :</strong> PostgreSQL, Oracle (hors configuration distribu√©e)</li>
  </ul>
  <aside class="notes">
    Ce mod√®le est adapt√© aux syst√®mes centralis√©s ou avec r√©seau fiable (cluster en LAN).  
    D√®s qu'une partition r√©seau appara√Æt, le syst√®me pr√©f√®re ne plus r√©pondre plut√¥t que risquer l'incoh√©rence.
  </aside>
</section>

<section>
  <h2>üü¢ AP : Availability + Partition Tolerance</h2>
  <ul>
    <li><strong>Avantages :</strong> haute disponibilit√© m√™me en cas de partitions</li>
    <li><strong>Inconv√©nients :</strong> possible incoh√©rence temporaire des donn√©es</li>
    <li><strong>Cas d'usage :</strong> syst√®mes web hautement disponibles (r√©seaux distribu√©s mondiaux)</li>
    <li><strong>Bases de donn√©es :</strong> CouchDB, Cassandra, DynamoDB</li>
  </ul>
  <aside class="notes">
    Ici, on accepte des lectures diff√©rentes ou des √©critures concurrentes, en √©change de la disponibilit√©.  
    On vise la scalabilit√© mondiale, quitte √† g√©rer des conflits plus tard (consistance √©ventuelle).
  </aside>
</section>

<section>
  <h2>üî¥ CP : Consistency + Partition Tolerance</h2>
  <ul>
    <li><strong>Avantages :</strong> forte coh√©rence m√™me en pr√©sence de partitions</li>
    <li><strong>Inconv√©nients :</strong> certaines requ√™tes √©chouent (sacrifiant la disponibilit√©)</li>
    <li><strong>Cas d'usage :</strong> syst√®mes bancaires, r√©servations</li>
    <li><strong>Bases de donn√©es :</strong> MongoDB (avec writeConcern √©lev√©), HBase, Zookeeper</li>
  </ul>
  <aside class="notes">
    Priorise la coh√©rence √† tout prix : le syst√®me peut refuser une op√©ration si la coh√©rence est incertaine.  
    Ce choix est commun pour les cas critiques comme les paiements ou r√©servations.
  </aside>
</section>

<section>
  <h2>üì¶ Bases de donn√©es et mod√®le CAP</h2>
  <table style="font-size: 0.7em;">
    <thead>
      <tr>
        <th>Type</th>
        <th>Exemples</th>
        <th>Mod√®le CAP</th>
        <th>Remarques</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Relationnel</td>
        <td>MySQL, PostgreSQL, Oracle, SQL Server, DB2</td>
        <td>üîµ CA</td>
        <td>Pas tol√©rant aux partitions ; mod√®le ACID classique</td>
      </tr>
      <tr>
        <td>Cl√©-Valeur</td>
        <td>Redis, Memcached, DynamoDB, CosmosDB</td>
        <td>üü¢ AP (DynamoDB configurable, CosmosDB PACELC)</td>
        <td>Redis peut √™tre üî¥ CP avec Sentinel ; CosmosDB propose plusieurs niveaux de coh√©rence</td>
      </tr>
      <tr>
        <td>Colonne</td>
        <td>Cassandra, HBase, BigTable, Elasticsearch</td>
        <td>
          Cassandra : üü¢ AP<br>
          HBase, BigTable : üî¥ CP<br>
          Elasticsearch : üü¢ AP
        </td>
        <td>Cassandra d√©riv√© de Dynamo ; HBase/BigTable visent la coh√©rence forte ; Elasticsearch tol√®re l‚Äôincoh√©rence</td>
      </tr>
      <tr>
        <td>Document</td>
        <td>MongoDB, Couchbase</td>
        <td>
          MongoDB : üî¥ CP (par d√©faut)<br>
          Couchbase : üü¢ AP
        </td>
        <td>MongoDB configurable via readConcern/writeConcern</td>
      </tr>
      <tr>
        <td>Graph</td>
        <td>Neo4j, OrientDB, FlockDB</td>
        <td>üü¢ AP</td>
        <td>G√©n√©ralement utilis√©s en cluster limit√©, peu orient√©s partitionnement</td>
      </tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau positionne les bases selon leurs garanties CAP dominantes.  
    La colonne "Remarques" aide √† comprendre les compromis internes ou les capacit√©s de configuration avanc√©e (ex. : CosmosDB, MongoDB).  
    Spark et SimpleDB ont √©t√© retir√©s pour clart√©.
  </aside>
</section>

<section>
  <h2>üîß Usages typiques et CAP</h2>
  <ul>
    <li><strong>üîµ CA (bases relationnelles)</strong> :
      <ul>
        <li>ERP, gestion comptable, syst√®mes de facturation</li>
        <li>Utilis√©s l√† o√π la <strong>coh√©rence forte</strong> est cruciale</li>
      </ul>
    </li>
    <li><strong>üü¢ AP (bases cl√©-valeur, colonne, document, graph)</strong> :
      <ul>
        <li>Applications web globales, r√©seaux sociaux, moteurs de recommandation</li>
        <li>Analyse de r√©seaux sociaux, gestion de d√©pendances (recommandations, cha√Ænes logistiques)</li>
        <li>Favorisent la <strong>disponibilit√©</strong> et la <strong>latence faible</strong></li>
        <li>Besoin de <strong>travers√©e rapide</strong> plut√¥t que coh√©rence forte</li>
      </ul>
    </li>
    <li><strong>üî¥ CP (bases colonne/document)</strong> :
      <ul>
        <li>Syst√®mes de messagerie, logs critiques, configuration distribu√©e</li>
        <li>La <strong>coh√©rence</strong> est maintenue m√™me au prix d'un blocage temporaire</li>
      </ul>
    </li>
  </ul>
  <aside class="notes">
    Ces usages illustrent pourquoi toutes les bases ne se valent pas :  
    le choix d√©pend du m√©tier, du besoin de coh√©rence, de disponibilit√©, et des contraintes r√©seau.  
    CAP est un outil d'orientation, pas une r√®gle rigide.
  </aside>
</section>


<section>
  <h2>üîó Sources</h2>
  <ul>
    <li><a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank">Wikipedia - CAP Theorem</a></li>
    <li><a href="https://code-garage.com/blog/comprendre-le-theoreme-cap" target="_blank">Comprendre le CAP theorem</a></li>
    <li><a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/" target="_blank">CAP Twelve Years Later (InfoQ)</a></li>
    <li><a href="https://aws.amazon.com/nosql/" target="_blank">AWS - NoSQL et CAP</a></li>
  </ul>
  <aside class="notes">
    Ces ressources approfondissent les compromis concrets du CAP dans des cas industriels r√©els.
  </aside>
</section>

<section>
  <h2>Consistance √©ventuelle & Idempotence</h2>
  <ul>
    <li><strong>Consistance √©ventuelle</strong> : √©tat convergent √† terme</li>
    <li><strong>Idempotence</strong> : un appel r√©p√©t√© ne change pas le r√©sultat</li>
  </ul>
  <aside class="notes">
    Ces propri√©t√©s sont essentielles dans les architectures tol√©rantes aux pannes ou asynchrones.
  </aside>
</section>

<!-- section>
  <h2>üö´ Th√©or√®me de FLP</h2>
  <ul>
    <li>Dans un syst√®me distribu√© <strong>asynchrone</strong> o√π un processus peut √©chouer,</li>
    <li>Il est <strong>impossible</strong> de garantir qu'un protocole atteindra toujours un consensus,</li>
    <li>m√™me avec des canaux fiables.</li>
  </ul>
  <aside class="notes">
    Le th√©or√®me FLP (1985) montre que le consensus est impossible √† garantir dans un syst√®me totalement asynchrone avec pannes possibles.  
    Cela explique pourquoi les syst√®mes comme Paxos ou Raft sont complexes ou probabilistes.
  </aside>
</section -->

<!-- section>
  <h2>‚è± Th√©or√®me de Lamport</h2>
  <ul>
    <li>Pas d'horloge globale dans un syst√®me distribu√©</li>
    <li>Mais possibilit√© de d√©finir un <strong>ordre logique</strong> entre √©v√©nements</li>
    <li><code>A ‚Üí B</code> signifie que A se produit avant B</li>
  </ul>
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Lamport%27s_logical_clocks.svg/480px-Lamport%27s_logical_clocks.svg.png" alt="Lamport Clock" style="max-height: 250px;" />
  <aside class="notes">
    Dans un syst√®me distribu√©, il n'y a pas de temps universel.  
    L'algorithme de Lamport attribue des timestamps logiques pour ordonner les √©v√©nements.  
    Base des CRDT, des syst√®mes √† journal distribu√©, etc.
  </aside>
</section -->

<section>
  <h2>‚öñÔ∏è Th√©or√®me PACELC</h2>
  <ul>
    <li>Compl√®te le CAP : si Partition, choix entre **Availability** ou **Consistency**</li>
    <li>Sinon (Else), choix entre **Latency** ou **Consistency**</li>
    <li>Formule : <strong>PACELC</strong> = <code>if P then A or C; else L or C</code></li>
  </ul>
  <aside class="notes">
    PACELC ajoute une dimension : m√™me sans partition, les bases doivent arbitrer entre latence et coh√©rence.  
    C'est un mod√®le plus r√©aliste pour les bases modernes comme DynamoDB ou CosmosDB.
  </aside>
</section>

<section>
  <h2>üß™ Exemples PACELC</h2>
  <ul>
    <li><strong>DynamoDB</strong> : PA/EL (disponible m√™me en partition, optimis√© pour latence)</li>
    <li><strong>BigTable</strong> : PC/EC (coh√©rence forte, quitte √† ralentir)</li>
    <li><strong>Cassandra</strong> : PA/EL (r√©plication et latence faible)</li>
  </ul>
  <aside class="notes">
    Dynamo et Cassandra privil√©gient la rapidit√© m√™me en cas d'incoh√©rence temporaire.  
    BigTable, au contraire, pr√©f√®re garantir des lectures coh√©rentes.  
    Le choix PACELC influence la conception applicative.
  </aside>
</section>

<!-- section>
  <h2>üìö Synth√®se p√©dagogique</h2>
  <table>
    <thead>
      <tr>
        <th>Th√©or√®me</th>
        <th>Pertinence p√©dagogique</th>
        <th>Int√©r√™t pratique</th>
        <th>Inclusion recommand√©e</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>FLP</td>
        <td>Moyenne</td>
        <td>Faible √† moyenne</td>
        <td>üåó 1 slide max, optionnel</td>
      </tr>
      <tr>
        <td>Lamport</td>
        <td>Haute</td>
        <td>Haute</td>
        <td>‚úÖ Oui, simple version</td>
      </tr>
      <tr>
        <td>PACELC</td>
        <td>Haute</td>
        <td>Haute</td>
        <td>‚úÖ Oui, compl√©ment CAP</td>
      </tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau aide √† d√©cider quels concepts approfondir ou simplement mentionner selon le temps, les objectifs et le niveau des √©tudiants.
  </aside>
</section -->

<section>
  <h2>üìã CAP vs PACELC</h2>
  <table>
    <thead>
      <tr><th>Mod√®le</th><th>Partition</th><th>Sans Partition</th><th>Avantage</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>CAP</strong></td>
        <td>Choix entre <strong>Availability</strong> ou <strong>Consistency</strong></td>
        <td>Non d√©fini</td>
        <td>Simple, fondamental</td>
      </tr>
      <tr>
        <td><strong>PACELC</strong></td>
        <td>Choix entre <strong>Availability</strong> ou <strong>Consistency</strong></td>
        <td>Choix entre <strong>Latency</strong> ou <strong>Consistency</strong></td>
        <td>Plus r√©aliste en pratique</td>
      </tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau montre que PACELC est une extension utile de CAP :  
    il ajoute la dimension de latence pour les cas sans partition, ce qui refl√®te mieux les compromis actuels dans les bases distribu√©es.
  </aside>
</section>

<section>
  <h2>‚öñÔ∏è ACID vs BASE</h2>
  <ul>
    <li><strong>ACID</strong> : mod√®le traditionnel pour bases relationnelles</li>
    <li><strong>BASE</strong> : approche plus souple, adapt√©e aux bases distribu√©es NoSQL</li>
  </ul>
  <aside class="notes">
    Ces deux mod√®les d√©finissent comment les syst√®mes g√®rent la coh√©rence et la fiabilit√© des transactions.  
    ACID est strict, BASE est tol√©rant : √† chaque besoin son mod√®le.
  </aside>
</section>

<section>
  <h2>üîí Mod√®le ACID</h2>
  <ul>
    <li><strong>Atomicity</strong> : tout ou rien</li>
    <li><strong>Consistency</strong> : √©tat valide avant/apr√®s la transaction</li>
    <li><strong>Isolation</strong> : pas d'interf√©rence entre transactions</li>
    <li><strong>Durability</strong> : une fois valid√©e, la transaction est persist√©e</li>
  </ul>
  <aside class="notes">
    ACID est con√ßu pour la fiabilit√© : tr√®s utile pour les syst√®mes critiques comme la banque, la facturation.  
    Il s'appuie sur un contr√¥le transactionnel fort.
  </aside>
</section>

<section>
  <h2>ACID - Avantages et limites</h2>
  <ul>
    <li><strong>‚úÖ Avantages :</strong> s√©curit√© des donn√©es, coh√©rence garantie</li>
    <li><strong>‚ö†Ô∏è Inconv√©nients :</strong> faible scalabilit√©, complexit√© en distribution</li>
    <li><strong>üìå Bases concern√©es :</strong> MySQL, PostgreSQL, Oracle, SQLite</li>
  </ul>
  <aside class="notes">
    Les bases ACID excellent sur un seul n≈ìud, mais se complexifient fortement en environnement distribu√©.  
    Elles sont n√©anmoins indispensables dans des cas comme les paiements ou l'ERP.
  </aside>
</section>

<section>
  <h2>üåä Mod√®le BASE</h2>
  <ul>
    <li><strong>Basically Available</strong> : le syst√®me r√©pond toujours, m√™me partiellement</li>
    <li><strong>Soft state</strong> : l'√©tat peut changer sans nouvelle √©criture</li>
    <li><strong>Eventual consistency</strong> : la coh√©rence est atteinte √† terme</li>
  </ul>
  <aside class="notes">
    BASE est une approche plus souple, pens√©e pour les syst√®mes distribu√©s massivement parall√®les.  
    Elle accepte des incoh√©rences temporaires pour garantir disponibilit√© et scalabilit√©.
  </aside>
</section>

<section>
  <h2>BASE - Avantages et limites</h2>
  <ul>
    <li><strong>‚úÖ Avantages :</strong> haute disponibilit√©, performance, tol√©rance r√©seau</li>
    <li><strong>‚ö†Ô∏è Inconv√©nients :</strong> incoh√©rences temporaires, gestion des conflits</li>
    <li><strong>üìå Bases concern√©es :</strong> Cassandra, DynamoDB, CouchDB, Riak</li>
  </ul>
  <aside class="notes">
    Les bases BASE sont adapt√©es √† des syst√®mes globalement distribu√©s, √† forte volum√©trie : r√©seaux sociaux, logs, IoT, etc.  
    La coh√©rence √©ventuelle demande une logique applicative robuste.
  </aside>
</section>

<section>
  <h2>üìä ACID vs BASE</h2>
  <table>
    <thead><tr><th>Propri√©t√©</th><th>ACID</th><th>BASE</th></tr></thead>
    <tbody>
      <tr><td>Disponibilit√©</td><td>Secondaire</td><td>Prioritaire</td></tr>
      <tr><td>Coh√©rence</td><td>Forte</td><td>√âventuelle</td></tr>
      <tr><td>Partition tolerance</td><td>Faible</td><td>Essentielle</td></tr>
      <tr><td>Performance</td><td>Stable</td><td>Optimis√©e</td></tr>
      <tr><td>Cas typique</td><td>Bancaire, ERP</td><td>Web, Big Data</td></tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau aide √† choisir la bonne approche selon le contexte m√©tier.  
    ACID = rigueur, BASE = scalabilit√©. Le choix n'est pas technique, il est fonctionnel.
  </aside>
</section>

<section>
  <h2>üîó Sources</h2>
  <ul>
    <li><a href="https://en.wikipedia.org/wiki/ACID" target="_blank">Wikipedia - ACID</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Eventual_consistency" target="_blank">Wikipedia - Eventual Consistency</a></li>
    <li><a href="https://www.infoq.com/articles/base-an-acid-alternative/" target="_blank">InfoQ - BASE: An ACID Alternative</a></li>
    <li><a href="https://martinfowler.com/articles/nosql-intro.html" target="_blank">Martin Fowler - NoSQL Intro</a></li>
  </ul>
  <aside class="notes">
    Vous pouvez approfondir la th√©orie et les cas pratiques de BASE et ACID √† travers ces articles.  
    Martin Fowler donne aussi un bon aper√ßu des implications dans les architectures NoSQL.
  </aside>
</section>