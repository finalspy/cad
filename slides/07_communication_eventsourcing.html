<!-- Slide 1: Titre et objectifs -->
<section>
  <h2>Introduction à l’Event Sourcing</h2>
  <ul>
    <li>Objectif : Comprendre le pattern Event Sourcing</li>
    <li>Structure : Questions / Réponses</li>
    <li>Exemples : Code, diagrammes Mermaid</li>
  </ul>
  <aside class="notes">
    Présenter le plan : nous allons poser des questions pour structurer le cours et y répondre de façon interactive.
  </aside>
</section>

<!-- Slide 2: Qu'est-ce que l’Event Sourcing ? -->
<section>
  <h3>Q1 : Qu'est-ce que l’Event Sourcing ?</h3>
  <p><strong>R :</strong> Toutes les modifications d'état sont stockées comme événements immuables ; le journal d’événements devient la source de vérité et l’état se reconstruit par relecture.</p>
  <aside class="notes">
    Citer Martin Fowler : « Event Sourcing is the pattern of storing state changes as a sequence of events » (martinfowler.com/eaaDev/EventSourcing.html).
  </aside>
</section>

<!-- Slide 3: Pourquoi utiliser l’Event Sourcing ? -->
<section>
  <h3>Q2 : Pourquoi utiliser l’Event Sourcing ?</h3>
  <ul>
    <li>Audit trail complet et infalsifiable</li>
    <li>Possibilité de rejouer l’historique pour débogage ou nouvelles fonctionnalités</li>
    <li>Versioning et rétro-compatibilité via évolutions contrôlées</li>
  </ul>
  <aside class="notes">
    Expliquer que chaque événement décrit une intention (par ex. OrderCreated) et qu’on peut “remonter le temps”.
  </aside>
</section>

<!-- Slide 4: Architecture générale -->
<section>
  <h3>Architecture Event Sourcing</h3>
  <pre><code class="language-mermaid">
graph LR
  A[Client] --> B(Command Handler)
  B --> C(Event Store)
  C --> D[Replayer / Projections]
  E[Snapshot Store] -.-> D
  D --> F[Read Models]
  A --> G[Query Handler]
  G --> F
  </code></pre>
  <aside class="notes">
    Décrire le flux : on append un événement, on met à jour les projections et éventuellement les snapshots.
  </aside>
</section>

<!-- Slide 5: Exemple de code – Append d’un événement (C#) -->
<section>
  <h3>Exemple : Append d’un événement</h3>
  <pre><code class="language-csharp">
// Définition de l’événement
public record OrderCreated(Guid OrderId, string Product, int Qty, DateTime Timestamp);

// Stockage dans l’Event Store
public async Task AppendEventAsync(IEvent e)
{
    var stream = GetStreamFor(e.AggregateId);
    await _eventStore.AppendToStreamAsync(stream, ExpectedVersion.Any, new[] { e });
}
  </code></pre>
  <aside class="notes">
    Montrer l’API d’un Event Store (par ex. EventStoreDB ou CosmosDB). Insister sur l’immuabilité des événements.
  </aside>
</section>

<!-- Slide 6: Exemple de code – Relecture / Reconstruction -->
<section>
  <h3>Exemple : Relecture des événements</h3>
  <pre><code class="language-csharp">
// Reconstruction d’un agrégat à partir des événements
public async Task<Order> LoadOrderAsync(Guid orderId)
{
    var events = await _eventStore.ReadStreamAsync("Order-" + orderId);
    var order = new Order();
    foreach (var e in events)
    {
        order.Apply(e);
    }
    return order;
}
  </code></pre>
  <aside class="notes">
    Expliquer la méthode Apply dans l’agrégat qui met à jour son état pour chaque type d’événement.
  </aside>
</section>

<!-- Slide 7: Cas d'usage et challenges -->
<section>
  <h3>Q3 : Quels sont les cas d’usage et challenges ?</h3>
  <ul>
    <li><strong>Cas d’usage :</strong> audit trail, historisation, débogage, analytics</li>
    <li><strong>Challenges :</strong> gestion des versions d’événements, schéma évolutif, orchestration des migrations</li>
    <li>Besoin de snapshots pour limiter le temps de reconstruction</li>
  </ul>
  <aside class="notes">
    Souligner la nécessité de versionner chaque événement et de migrer les anciens formats.
  </aside>
</section>

<!-- Slide 8: Snapshots -->
<section>
  <h3>Q4 : Pourquoi et comment créer des snapshots ?</h3>
  <ul>
    <li>Optimiser la reconstruction : éviter de relire des milliers d’événements</li>
    <li>Snapshot = état de l’agrégat à un instant T</li>
    <li>Exemple de code :</li>
  </ul>
  <pre><code class="language-csharp">
// Sauvegarde de snapshot
public async Task SaveSnapshotAsync(OrderSnapshot snap)
{
    await _snapshotStore.SaveAsync(snap.AggregateId, snap.Version, snap);
}
  </code></pre>
  <aside class="notes">
    Expliquer la stratégie de fréquence de snapshot (par ex. tous les 100 événements ou toutes les heures).
  </aside>
</section>

<!-- Slide 9: Évolution du schéma d’événements -->
<section>
  <h3>Q5 : Comment gérer l’évolution des événements ?</h3>
  <ul>
    <li>Inclure un champ de version dans chaque événement</li>
    <li>Écrire des adaptateurs (« upcasters ») pour transformer les anciens événements</li>
    <li>Maintenir la compatibilité ascendante</li>
  </ul>
  <aside class="notes">
    Donner un exemple simple d’upcaster qui ajoute un nouveau champ avec une valeur par défaut.
  </aside>
</section>

<!-- Slide 10: Conclusion -->
<section>
  <h2>Conclusion</h2>
  <ul>
    <li>Event Sourcing stocke chaque changement d’état en tant qu’événement immuable</li>
    <li>Apporte audit, rejouabilité, versioning mais augmente la complexité</li>
    <li>Les snapshots et l’upcasting sont essentiels pour la performance et l’évolutivité</li>
    <li>Souvent couplé à CQRS pour séparer lecture et écriture</li>
  </ul>
  <aside class="notes">
    Résumer les avantages et inconvénients, rappeler la combinaison fréquente avec CQRS.
  </aside>
</section>

<!-- Slide 11: Références -->
<section>
  <h2>Références</h2>
  <ul>
    <li>Martin Fowler – Event Sourcing : <a href="https://martinfowler.com/eaaDev/EventSourcing.html">martinfowler.com/eaaDev/EventSourcing.html</a></li>
    <li>Greg Young – Learn Event Sourcing : <a href="https://eventstore.org/docs/getting-started/event-sourcing-basics/index.html">eventstore.org/docs</a></li>
    <li>Microsoft Docs – Patterns : <a href="https://docs.microsoft.com/azure/architecture/patterns/event-sourcing">docs.microsoft.com/azure/architecture/patterns/event-sourcing</a></li>
  </ul>
  <aside class="notes">
    Encourager la lecture de ces ressources pour approfondir la mise en œuvre et les outils.
  </aside>
</section>

<!-- Slide 12: Questions -->
<section>
  <h2>Questions</h2>
  <ul>
    <li>Comment choisir la fréquence des snapshots ?</li>
    <li>Quels mécanismes pour migrer les anciens événements ?</li>
    <li>Quelles alternatives si la volumétrie d’événements est limitée ?</li>
  </ul>
  <aside class="notes">
    Stimuler la discussion sur la mise en œuvre opérationnelle et les choix d’architecture.
  </aside>
</section>
