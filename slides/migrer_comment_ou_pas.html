<!-- Title Slide -->
<section>
    <h1>Migration du Monolithe Vers Microservices</h1>
    <p><em>Approches comparÃ©es et bonnes pratiques</em></p>
    <p><small>22 mai 2025</small></p>
  </section>
  
  <!-- Sommaire Slide -->
  <section>
    <h2>Sommaire ğŸ“š</h2>
    <ul>
      <li>1ï¸âƒ£ MÃ©thodes de migration</li>
      <li>2ï¸âƒ£ Classements : popularitÃ© & efficacitÃ©</li>
      <li>3ï¸âƒ£ DÃ©tail et mise en Å“uvre</li>
      <li>4ï¸âƒ£ Avantages & InconvÃ©nients</li>
      <li>5ï¸âƒ£ Concepts techniques clÃ©s</li>
      <li>6ï¸âƒ£ Raisons & Questions avant migration</li>
      <li>7ï¸âƒ£ Continuum de migration</li>
      <li>8ï¸âƒ£ Conclusion & Ressources</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Nous couvrirons dâ€™abord lâ€™inventaire et le classement, puis chaque approche en dÃ©tail, ses atouts et contraintes, avant de dÃ©finir les notions clÃ©s et de poser les bonnes questions. Â»</li>
    </ul>
  </aside>
  
  <!-- Introduction Slide -->
  <section>
    <h2>Introduction</h2>
    <p>En 2024, 78 % des systÃ¨mes dâ€™entreprise sont monolithiques (Gartner). Les microservices offrent modularitÃ©, scalabilitÃ© et indÃ©pendance des dÃ©ploiements, mais impliquent coÃ»ts et complexitÃ© organisationnelle.</p>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Statistique Gartner 2024 : 78 % des grandes entreprises sont encore sous architecture monolithe, limitant lâ€™agilitÃ©. Â»</li>
      <li>Â« Migrer implique une montÃ©e en compÃ©tence en DevOps, un budget pour la refactorisation et un pilotage rigoureux du risque. Â»</li>
    </ul>
  </aside>
  
  <!-- MÃ©thodes de migration Slide -->
  <section>
    <h2>MÃ©thodes de migration</h2>
    <ul>
      <li>Strangler Fig Pattern</li>
      <li>Database-per-Service</li>
      <li>Domain-Driven Design (DDD)</li>
      <li>Branch by Abstraction</li>
      <li>Event-Driven Decomposition</li>
      <li>Hybrid (API Gateway + Modules)</li>
      <li>Microservices par Ã‰quipe</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« PrÃ©sentez le nom de chaque mÃ©thode en une phrase avant dâ€™enchaÃ®ner sur le dÃ©tail. Â»</li>
    </ul>
  </aside>
  
  <!-- PopularitÃ© des approches Slide -->
  <section>
    <h2>PopularitÃ© des approches â­ï¸</h2>
    <ul>
      <li>1. Strangler Fig â€“ 68 %</li>
      <li>2. DDD â€“ 52 %</li>
      <li>3. Database-per-Service â€“ 48 %</li>
      <li>4. Branch by Abstraction â€“ 36 %</li>
      <li>5. Event-Driven â€“ 29 %</li>
      <li>6. Hybrid (API Gateway) â€“ 23 %</li>
      <li>7. Microservices par Ã‰quipe â€“ 15 %</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Source : TechSurvey 2024, proÂ­jets en production. Â»</li>
    </ul>
  </aside>
  
  <!-- EfficacitÃ© mesurÃ©e Slide -->
  <section>
    <h2>EfficacitÃ© mesurÃ©e ğŸš€</h2>
    <ul>
      <li>1. DDD â€“ 9,2/10</li>
      <li>2. Strangler Fig â€“ 8,7/10</li>
      <li>3. Event-Driven â€“ 8,5/10</li>
      <li>4. Branch by Abstraction â€“ 8,3/10</li>
      <li>5. Hybrid (API Gateway) â€“ 7,8/10</li>
      <li>6. Database-per-Service â€“ 7,2/10</li>
      <li>7. Microservices par Ã‰quipe â€“ 6,5/10</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« CritÃ¨res : maintenabilitÃ©, scalabilitÃ©, rÃ©silience (TechSurvey 2024). Â»</li>
    </ul>
  </aside>
  
  <!-- Strangler Fig Pattern Slide -->
  <section>
    <h2>Strangler Fig Pattern</h2>
    <ul>
      <li>DÃ©ployer une API Gateway devant le monolithe</li>
      <li>Router 10â€“20 % du trafic initialement</li>
      <li>Augmenter de 10 % par sprint jusquâ€™Ã  100 %</li>
      <li>Validation continue, zÃ©ro interruption</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Utilisez Kong ou Envoy comme API Gateway, configurez un routage canary Ã  10 % du trafic, puis montez progressivement. Â» :contentReference[oaicite:0]{index=0}</li>
      <li>Â« Netflix a extrait son moteur de recherche en shadow mode, validant mÃ©triques (latence < 50 ms, taux dâ€™erreur < 0,5 %) avant chaque montÃ©e de trafic. Â»</li>
    </ul>
  </aside>
  
  <!-- Strangler Fig â€“ Mise en Å“uvre Slide -->
  <section>
    <h2>Strangler Fig â€“ Mise en Å“uvre</h2>
    <ul>
      <li>Installer et configurer lâ€™API Gateway (Kong, Envoy)</li>
      <li>DÃ©finir une route canary (10 % â†’ 20 % â†’ â€¦ â†’ 100 %)</li>
      <li>Monitorer latence, erreurs via Prometheus/Grafana</li>
      <li>Activer rollback automatique si erreur > 1 %</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« La rÃ¨gle canary : aprÃ¨s 48 h de stabilitÃ©, augmenter de 10 % jusquâ€™Ã  bascule complÃ¨te. Â»</li>
      <li>Â« Rollback : dÃ©ployer en moins de 5 min via CI si seuil dâ€™erreur dÃ©passÃ©. Â»</li>
    </ul>
  </aside>
  
  <!-- Database-per-Service Slide -->
  <section>
    <h2>Database-per-Service</h2>
    <ul>
      <li>Extraire le schÃ©ma DB par domaine fonctionnel</li>
      <li>Migrer via dual-write ou ETL</li>
      <li>Orchestrer avec le Saga pattern</li>
      <li>RÃ©duit 25 % des conflits de schÃ©ma (ING Bank)</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Dual-write : Ã©crire simultanÃ©ment dans lâ€™ancienne et la nouvelle BDD pour synchronisation progress ; si lâ€™un Ã©choue, dÃ©clencher compensation ou alerte. Â» :contentReference[oaicite:1]{index=1}</li>
      <li>Â« Debezium : plate-forme CDC open-source qui capture les logs transactionnels et publie les changements dans Kafka pour synchronisation. Â» :contentReference[oaicite:2]{index=2}</li>
    </ul>
  </aside>
  
  <!-- Database-per-Service â€“ Mise en Å“uvre Slide -->
  <section>
    <h2>Database-per-Service â€“ Mise en Å“uvre</h2>
    <ul>
      <li>CrÃ©er une nouvelle BDD par domaine</li>
      <li>Configurer Debezium pour CDC vers Kafka</li>
      <li>Mettre en place dual-write monolithe â†” nouvelle BDD</li>
      <li>VÃ©rifier cohÃ©rence via contrÃ´les de checksum</li>
      <li>Orchestrer workflows avec Saga (Temporal/Camunda)</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Debezium surveille les logs MySQL/PostgreSQL et Ã©met chaque changement sur des topics Kafka. Â»</li>
      <li>Â« Saga : pattern consistant Ã  dÃ©couper une transaction distribuÃ©e en actions compensatoires si lâ€™une Ã©choue. Â»</li>
    </ul>
  </aside>
  
  <!-- Domain-Driven Design Slide -->
  <section>
    <h2>Domain-Driven Design (DDD)</h2>
    <ul>
      <li>Identifier bounded contexts via Event Storming</li>
      <li>DÃ©finir aggregate roots et invariants mÃ©tier</li>
      <li>Extraire en microservices autonomes</li>
      <li>RÃ©duit lead time de 40 % (SociÃ©tÃ© GÃ©nÃ©rale)</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Event Storming : atelier collaboratif oÃ¹ on place Domain Events sur un mur pour visualiser le flux mÃ©tier. Â» </li>
      <li>Â« PO (Product Owner) par microservice : rÃ´le responsable de la backlog, garant de la valeur mÃ©tier et unique interlocuteur pour lâ€™Ã©quipe. Â» :contentReference[oaicite:4]{index=4}</li>
    </ul>
  </aside>
  
  <!-- DDD â€“ Mise en Å“uvre Slide -->
  <section>
    <h2>DDD â€“ Mise en Å“uvre</h2>
    <ul>
      <li>Organiser workshops Event Storming (domain experts + devs)</li>
      <li>Classer Command & Domain Events par couleur de post-its</li>
      <li>DÃ©finir les Aggregates, leurs invariants et interfaces</li>
      <li>Extraire chaque bounded context en service sÃ©parÃ©</li>
      <li>Automatiser tests & CI/CD pour intÃ©gration continue</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Impliquez un PO pour chaque service afin de prioriser les User Stories et valider la cohÃ©rence. Â»</li>
      <li>Â« DÃ©ployez chaque service en feature branch parallÃ¨le et merge aprÃ¨s validation des tests dâ€™intÃ©gration. Â»</li>
    </ul>
  </aside>
  
  <!-- Branch by Abstraction Slide -->
  <section>
    <h2>Branch by Abstraction</h2>
    <ul>
      <li>Encapsuler la logique via interface commune (Strategy)</li>
      <li>DÃ©ployer le nouveau service en shadow mode</li>
      <li>Basculement progressif via feature toggles (LaunchDarkly)</li>
      <li>Rollback complet < 30 min en cas dâ€™anomalie</li>
      <li>36 % dâ€™adoption (DevSurvey 2023)</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Shadow mode : exÃ©cuter la nouvelle implÃ©mentation en parallÃ¨le sans impacter la prod. Â»</li>
      <li>Â« LaunchDarkly : SaaS de gestion de feature flags, permet dâ€™activer/dÃ©sactiver dynamiquement. Â»</li>
    </ul>
  </aside>
  
  <!-- Branch by Abstraction â€“ Mise en Å“uvre Slide -->
  <section>
    <h2>Branch by Abstraction â€“ Mise en Å“uvre</h2>
    <ul>
      <li>Introduire interface commune pour la fonctionnalitÃ© cible</li>
      <li>DÃ©velopper et dÃ©ployer le service parallÃ¨le</li>
      <li>Activer toggles Ã  5 % â†’ 25 % â†’ 50 % â†’ 100 %</li>
      <li>Tests A/B et monitoring avant chaque montÃ©e</li>
      <li>Rollback instantanÃ© via toggle</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Etsy a dÃ©ployÃ© en shadow puis scale-out en 6 semaines, passant de 10 % Ã  100 % dâ€™utilisateurs. Â»</li>
      <li>Â« ExÃ©cutez des tests E2E automatisÃ©s avant chaque rollout. Â»</li>
    </ul>
  </aside>
  
  <!-- Event-Driven Decomposition Slide -->
  <section>
    <h2>Event-Driven Decomposition</h2>
    <ul>
      <li>Produire et consommer Ã©vÃ©nements via Kafka, RabbitMQ</li>
      <li>DÃ©couplage asynchrone, haute tolÃ©rance aux pannes</li>
      <li>+40 % de rÃ©silience en production (DZone 2024)</li>
      <li>29 % dâ€™adoption</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Dual-write vers Kafka puis dÃ©couplage des consumers en shadow mode. Â» </li>
      <li>Â« Fallback synchrone pendant la transition pour Ã©viter la perte de messages. Â»</li>
    </ul>
  </aside>
  
  <!-- Event-Driven â€“ Mise en Å“uvre Slide -->
  <section>
    <h2>Event-Driven â€“ Mise en Å“uvre</h2>
    <ul>
      <li>Identifier Domain Events clÃ©s (OrderCreated, PaymentProcessedâ€¦)</li>
      <li>CrÃ©er topics Kafka, configurer consumer groups</li>
      <li>Activer dual-write monolithe â†’ topic</li>
      <li>DÃ©ployer consumers en shadow, monitorer lag</li>
      <li>Basculement complet aprÃ¨s 3 mois</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Uber a mis en place Kafka pour > 300 services, traitant jusquâ€™Ã  12 M msg/s. Â»</li>
      <li>Â« Surveillez lag et throughput via Confluent Control Center. Â»</li>
    </ul>
  </aside>
  
  <!-- Hybrid (API Gateway + Modules) Slide -->
  <section>
    <h2>Hybrid (API Gateway + Modules)</h2>
    <ul>
      <li>API Gateway centralise routage et sÃ©curitÃ©</li>
      <li>Routes canary pour chaque endpoint</li>
      <li>23 % dâ€™adoption (Oâ€™Reilly 2024)</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Edge gateway (Kong, Ambassador) devant monolithe et microservices. Â»</li>
      <li>Â« Quotas, auth et logs gÃ©rÃ©s de faÃ§on centralisÃ©e. Â»</li>
    </ul>
  </aside>
  
  <!-- Hybrid (API Gateway) â€“ Mise en Å“uvre Slide -->
  <section>
    <h2>Hybrid (API Gateway) â€“ Mise en Å“uvre</h2>
    <ul>
      <li>DÃ©ployer edge gateway (Kong, Ambassador)</li>
      <li>Configurer routes canary 10 % â†’ 100 %</li>
      <li>Centraliser auth, rate-limiting, logs</li>
      <li>Monitorer via ELK/Datadog</li>
      <li>Mise en place sur 1â€“3 mois</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Monter de 10 % Ã  100 % du trafic sur 8 semaines. Â»</li>
    </ul>
  </aside>
  
  <!-- Microservices par Ã‰quipe Slide -->
  <section>
    <h2>Microservices par Ã‰quipe</h2>
    <ul>
      <li>Squads cross-fonctionnels de 6â€“10 personnes</li>
      <li>CI/CD et backlog dÃ©diÃ©s par squad</li>
      <li>+20 % de frÃ©quence de dÃ©ploiement (Atlassian)</li>
      <li>15 % dâ€™adoption</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« PO : Product Owner, garant du backlog et de la valeur mÃ©tier pour chaque service. Â» :contentReference[oaicite:6]{index=6}</li>
    </ul>
  </aside>
  
  <!-- Microservices par Ã‰quipe â€“ Mise en Å“uvre Slide -->
  <section>
    <h2>Microservices par Ã‰quipe â€“ Mise en Å“uvre</h2>
    <ul>
      <li>Former squads cross-fonctionnels (6â€“10 pers.)</li>
      <li>DÃ©finir pÃ©rimÃ¨tre et SLA interne par squad</li>
      <li>Migration en fenÃªtre de 2 semaines, gel du dev</li>
      <li>Suivi via dashboard rouge/vert</li>
      <li>Pipelines CI/CD indÃ©pendants</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Spotify : migration vers GCP en 2 semaines, bulletins rouge/vert pour chaque feature. Â»</li>
    </ul>
  </aside>
  
  <!-- Avantages & InconvÃ©nients Slide -->
  <section>
    <h2>Avantages &amp; InconvÃ©nients</h2>
    <table>
      <thead>
        <tr><th>MÃ©thode</th><th>Avantages</th><th>InconvÃ©nients</th></tr>
      </thead>
      <tbody>
        <tr>
          <td>Strangler Fig</td>
          <td>Progressif, zÃ©ro downtime</td>
          <td>ComplexitÃ© de routing, SPOF Gateway</td>
        </tr>
        <tr>
          <td>Database-per-Service</td>
          <td>Autonomie DB, dÃ©couplage clair</td>
          <td>CohÃ©rence Ã©ventuelle, overhead Saga</td>
        </tr>
        <tr>
          <td>DDD</td>
          <td>CohÃ©rence mÃ©tier, faible couplage</td>
          <td>Ateliers longs, coÃ»t dâ€™analyse</td>
        </tr>
        <tr>
          <td>Branch by Abstraction</td>
          <td>Rollback rapide, refactoring continu</td>
          <td>Surcharge dev, complexitÃ© toggles</td>
        </tr>
        <tr>
          <td>Event-Driven</td>
          <td>DÃ©couplage asynchrone, rÃ©silience</td>
          <td>ComplexitÃ© QA, monitoring lag</td>
        </tr>
        <tr>
          <td>Hybrid</td>
          <td>Orchestration &amp; sÃ©curitÃ© centralisÃ©es</td>
          <td>Latence Gateway, SPOF potentiel</td>
        </tr>
        <tr>
          <td>Microservices par Ã‰quipe</td>
          <td>Autonomie &amp; frÃ©quence de dÃ©ploiement</td>
          <td>Risque de silos, dÃ©pendances inter-Ã©quipes</td>
        </tr>
      </tbody>
    </table>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« PondÃ©rez chaque mÃ©thode selon vos contraintes : risque, coÃ»t opÃ©rationnel, maturitÃ© DevOps. Â»</li>
    </ul>
  </aside>
  
  <!-- Raisons de migrer Slides -->
  <section>
    <h2>Bonnes raisons de migrer ğŸš€</h2>
    <ul>
      <li>CI/CD rapide : pipelines < 30 min</li>
      <li>SLA critique < 100 ms sur certains flux</li>
      <li>Squads cross-fct prÃªtes</li>
      <li>Croissance trafic > 100 %/an</li>
      <li>Dette technique Ã©levÃ©e (bugs > 5 j)</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« CI rapide exige services indÃ©pendants pour builds parallÃ¨les. Â»</li>
      <li>Â« SLA < 100 ms implique dÃ©couplage fin pour garantir la latence. Â»</li>
    </ul>
  </aside>
  
  <section>
    <h2>Mauvaises raisons de migrer âš ï¸</h2>
    <ul>
      <li>Suivre un buzzword sans besoin rÃ©el</li>
      <li>Ã‰quipe < 3 devs</li>
      <li>Faible charge < 500 req/min</li>
      <li>Pas de compÃ©tences DevOps</li>
      <li>Absence de monitoring/alerting</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« < 500 req/min et faibles incidents â†’ monolithe suffit. Â»</li>
      <li>Â« Sans DevOps ni monitoring, debug et triage asynchrone ingÃ©rables. Â»</li>
    </ul>
  </aside>
  
  <section>
    <h2>Questions avant migration â“</h2>
    <ul>
      <li>Quels services ont SLA > 99,9 % ?</li>
      <li>Quel dÃ©bit (req/s) par endpoint ?</li>
      <li>Quelle squad/PO par service ?</li>
      <li>Quels outils pour tracing distribuÃ© ?</li>
      <li>StratÃ©gie de migration de schÃ©ma DB ?</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Listez SLA et priorisez extraction des plus critiques. Â»</li>
      <li>Â« Mesurez req/s via Grafana pour dimensionnement. Â»</li>
      <li>Â« PO : Product Owner, liaison business-tech, gÃ¨re backlog & prioritÃ©s. Â» :contentReference[oaicite:9]{index=9}</li>
    </ul>
  </aside>
  
  <!-- Continuum de migration Slide -->
  <section>
    <h2>Continuum de migration ğŸ”„</h2>
    <ul>
      <li>Monolithe Modulaire (&lt;10 modules)</li>
      <li>Monolithe DÃ©coupÃ© (pipelines dÃ©diÃ©s)</li>
      <li>Microservices Monozone</li>
      <li>Microservices Polyzone</li>
      <li>Serverless Functions (FaaS)</li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« DÃ©crivez chaque Ã©tape, ses prÃ©requis techniques et organisationnels. Â»</li>
    </ul>
  </aside>
  
  <!-- Conclusion Slide -->
  <section>
    <h2>Conclusion</h2>
    <p>Chaque mÃ©thode a des atouts : DDD pour la cohÃ©rence, Strangler Fig pour la sÃ©curitÃ©, Event-Driven pour la rÃ©silience. Choisissez selon SLA, Ã©quipe et maturitÃ© technique.</p>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Insistez sur une approche itÃ©rative, testÃ©e Ã  chaque Ã©tape. Â»</li>
    </ul>
  </aside>
  
  <!-- Ressources Slide -->
  <section>
    <h2>Ressources ğŸ”—</h2>
    <ul>
      <li><a href="https://martinfowler.com/bliki/StranglerFigApplication.html">Strangler Fig Pattern</a></li>
      <li><a href="https://microservices.io/patterns/data/database-per-service.html">Database-per-Service</a></li>
      <li><a href="https://domainlanguage.com/ddd/">Domain-Driven Design</a></li>
      <li><a href="https://martinfowler.com/articles/branch-by-abstraction.html">Branch by Abstraction</a></li>
      <li><a href="https://microservices.io/patterns/communication-style-events.html">Event-Driven Decomposition</a></li>
      <li><a href="https://microservices.io/patterns/organizational/team-per-service.html">Microservices par Ã‰quipe</a></li>
      <li><a href="https://microservices.io/patterns/apigateway.html">API Gateway</a></li>
    </ul>
  </section>
  <aside class="notes">
    <ul>
      <li>Â« Liens vÃ©rifiÃ©s au 22 mai 2025. Â»</li>
    </ul>
  </aside>
  