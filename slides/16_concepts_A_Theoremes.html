<!-- Slide d'introduction gÃ©nÃ©rale -->
<section data-background-image="/public/images/titre_concepts.jpg" 
          data-background-size="cover"
          data-background-opacity="0.5">
  <h1>Concepts clÃ©s</h1>
  <ul>
    <li><b>ğŸ”º ThÃ©orÃ¨mes fondamentaux</b></li>
    <li>ğŸŒ Concepts et Techniques ClÃ©s</li>
    <li>ğŸ§© Architecture et Design</li>
    <li>ğŸ›¡ï¸ RÃ©silience et ScalabilitÃ©</li>
    <li>ğŸ§ª Tests et ObservabilitÃ©</li>
    <li>ğŸ§  Gouvernance et Ã‰quipes</li>
  </ul>
</section>

<!-- === SECTION 1 : ThÃ©orÃ¨mes fondamentaux === -->
<section>
  <h2>ğŸ”º ThÃ©orÃ¨mes fondamentaux</h2>
  <ul>
    <li>ThÃ©orÃ¨me de Brewer (CAP)</li>
    <li>ACID / BASE</li>
    <!--li>ThÃ©orÃ¨me de FLP</li>
    <li>ThÃ©orÃ¨me de Lamport</li>
    <li>ThÃ©orÃ¨me de PACELC</li-->
  </ul>
  <aside class="notes">
    Ces thÃ©orÃ¨mes posent les limites thÃ©oriques des systÃ¨mes distribuÃ©s. Ils influencent tous les choix techniques ultÃ©rieurs.
  </aside>
</section>

<section>
  <h2>CAP Theorem</h2>
  <ul>
    <li><strong>Consistency</strong>: mÃªme valeur pour tous les nÅ“uds</li>
    <li><strong>Availability</strong>: rÃ©ponse Ã  chaque requÃªte</li>
    <li><strong>Partition Tolerance</strong>: robustesse en cas de rupture rÃ©seau</li>
  </ul>
  <aside class="notes">
    Dans un systÃ¨me distribuÃ©, on ne peut garantir les trois Ã  la fois. CAP nous oblige Ã  faire des compromis.
  </aside>
</section>

<section>
  <h2>CAP Theorem</h2>
  <!-- img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/CAP_theorem.svg/500px-CAP_theorem.svg.png" alt="Diagramme CAP" style="max-height: 400px;" /-->
  <img src="/public/schemas/cap.jpg" alt="Diagramme CAP" style="max-height: 400px;" />
  <aside class="notes">
    Le thÃ©orÃ¨me CAP (Brewer, 2000) dit qu'un systÃ¨me distribuÃ© ne peut garantir simultanÃ©ment CohÃ©rence, DisponibilitÃ© et TolÃ©rance au partitionnement.  
    Il faut choisir deux propriÃ©tÃ©s selon le besoin.
  </aside>
</section>

<section>
  <h2>Les 3 propriÃ©tÃ©s CAP</h2>
  <ul>
    <li><strong>C</strong> - Consistency : Tous les nÅ“uds voient les mÃªmes donnÃ©es en mÃªme temps.</li>
    <li><strong>A</strong> - Availability : Chaque requÃªte reÃ§oit une rÃ©ponse, mÃªme en cas de panne.</li>
    <li><strong>P</strong> - Partition Tolerance : Le systÃ¨me continue Ã  fonctionner malgrÃ© des dÃ©faillances rÃ©seau.</li>
  </ul>
  <aside class="notes">
    Lorsqu'une partition rÃ©seau survient, vous devez sacrifier soit la cohÃ©rence soit la disponibilitÃ©. Ce choix dÃ©pend du cas d'usage.
  </aside>
</section>

<section>
  <h2>ğŸ”µ CA : Consistency + Availability</h2>
  <ul>
    <li><strong>Avantages :</strong> rÃ©ponses cohÃ©rentes et toujours disponibles tant que le rÃ©seau est fiable</li>
    <li><strong>InconvÃ©nients :</strong> si une partition survient, le systÃ¨me devient indisponible</li>
    <li><strong>Cas d'usage :</strong> systÃ¨mes en cluster local (pas rÃ©partis sur Internet)</li>
    <li><strong>Bases de donnÃ©es :</strong> PostgreSQL, Oracle (hors configuration distribuÃ©e)</li>
  </ul>
  <aside class="notes">
    Ce modÃ¨le est adaptÃ© aux systÃ¨mes centralisÃ©s ou avec rÃ©seau fiable (cluster en LAN).  
    DÃ¨s qu'une partition rÃ©seau apparaÃ®t, le systÃ¨me prÃ©fÃ¨re ne plus rÃ©pondre plutÃ´t que risquer l'incohÃ©rence.
  </aside>
</section>

<section>
  <h2>ğŸŸ¢ AP : Availability + Partition Tolerance</h2>
  <ul>
    <li><strong>Avantages :</strong> haute disponibilitÃ© mÃªme en cas de partitions</li>
    <li><strong>InconvÃ©nients :</strong> possible incohÃ©rence temporaire des donnÃ©es</li>
    <li><strong>Cas d'usage :</strong> systÃ¨mes web hautement disponibles (rÃ©seaux distribuÃ©s mondiaux)</li>
    <li><strong>Bases de donnÃ©es :</strong> CouchDB, Cassandra, DynamoDB</li>
  </ul>
  <aside class="notes">
    Ici, on accepte des lectures diffÃ©rentes ou des Ã©critures concurrentes, en Ã©change de la disponibilitÃ©.  
    On vise la scalabilitÃ© mondiale, quitte Ã  gÃ©rer des conflits plus tard (consistance Ã©ventuelle).
  </aside>
</section>

<section>
  <h2>ğŸ”´ CP : Consistency + Partition Tolerance</h2>
  <ul>
    <li><strong>Avantages :</strong> forte cohÃ©rence mÃªme en prÃ©sence de partitions</li>
    <li><strong>InconvÃ©nients :</strong> certaines requÃªtes Ã©chouent (sacrifiant la disponibilitÃ©)</li>
    <li><strong>Cas d'usage :</strong> systÃ¨mes bancaires, rÃ©servations</li>
    <li><strong>Bases de donnÃ©es :</strong> MongoDB (avec writeConcern Ã©levÃ©), HBase, Zookeeper</li>
  </ul>
  <aside class="notes">
    Priorise la cohÃ©rence Ã  tout prix : le systÃ¨me peut refuser une opÃ©ration si la cohÃ©rence est incertaine.  
    Ce choix est commun pour les cas critiques comme les paiements ou rÃ©servations.
  </aside>
</section>

<section>
  <h2>ğŸ“¦ Bases de donnÃ©es et modÃ¨le CAP</h2>
  <table style="font-size: 0.7em;">
    <thead>
      <tr>
        <th>Type</th>
        <th>Exemples</th>
        <th>ModÃ¨le CAP</th>
        <th>Remarques</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Relationnel</td>
        <td>MySQL, PostgreSQL, Oracle, SQL Server, DB2</td>
        <td>ğŸ”µ CA</td>
        <td>Pas tolÃ©rant aux partitions ; modÃ¨le ACID classique</td>
      </tr>
      <tr>
        <td>ClÃ©-Valeur</td>
        <td>Redis, Memcached, DynamoDB, CosmosDB</td>
        <td>ğŸŸ¢ AP (DynamoDB configurable, CosmosDB PACELC)</td>
        <td>Redis peut Ãªtre ğŸ”´ CP avec Sentinel ; CosmosDB propose plusieurs niveaux de cohÃ©rence</td>
      </tr>
      <tr>
        <td>Colonne</td>
        <td>Cassandra, HBase, BigTable, Elasticsearch</td>
        <td>
          Cassandra : ğŸŸ¢ AP<br>
          HBase, BigTable : ğŸ”´ CP<br>
          Elasticsearch : ğŸŸ¢ AP
        </td>
        <td>Cassandra dÃ©rivÃ© de Dynamo ; HBase/BigTable visent la cohÃ©rence forte ; Elasticsearch tolÃ¨re l'incohÃ©rence</td>
      </tr>
      <tr>
        <td>Document</td>
        <td>MongoDB, Couchbase</td>
        <td>
          MongoDB : ğŸ”´ CP (par dÃ©faut)<br>
          Couchbase : ğŸŸ¢ AP
        </td>
        <td>MongoDB configurable via readConcern/writeConcern</td>
      </tr>
      <tr>
        <td>Graph</td>
        <td>Neo4j, OrientDB, FlockDB</td>
        <td>ğŸŸ¢ AP</td>
        <td>GÃ©nÃ©ralement utilisÃ©s en cluster limitÃ©, peu orientÃ©s partitionnement</td>
      </tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau positionne les bases selon leurs garanties CAP dominantes.  
    La colonne "Remarques" aide Ã  comprendre les compromis internes ou les capacitÃ©s de configuration avancÃ©e (ex. : CosmosDB, MongoDB).  
    Spark et SimpleDB ont Ã©tÃ© retirÃ©s pour clartÃ©.
  </aside>
</section>

<section>
  <h2>ğŸ”§ Usages typiques et CAP</h2>
  <ul>
    <li><strong>ğŸ”µ CA (bases relationnelles)</strong> :
      <ul>
        <li>ERP, gestion comptable, systÃ¨mes de facturation</li>
        <li>UtilisÃ©s lÃ  oÃ¹ la <strong>cohÃ©rence forte</strong> est cruciale</li>
      </ul>
    </li>
    <li><strong>ğŸŸ¢ AP (bases clÃ©-valeur, colonne, document, graph)</strong> :
      <ul>
        <li>Applications web globales, rÃ©seaux sociaux, moteurs de recommandation</li>
        <li>Analyse de rÃ©seaux sociaux, gestion de dÃ©pendances (recommandations, chaÃ®nes logistiques)</li>
        <li>Favorisent la <strong>disponibilitÃ©</strong> et la <strong>latence faible</strong></li>
        <li>Besoin de <strong>traversÃ©e rapide</strong> plutÃ´t que cohÃ©rence forte</li>
      </ul>
    </li>
    <li><strong>ğŸ”´ CP (bases colonne/document)</strong> :
      <ul>
        <li>SystÃ¨mes de messagerie, logs critiques, configuration distribuÃ©e</li>
        <li>La <strong>cohÃ©rence</strong> est maintenue mÃªme au prix d'un blocage temporaire</li>
      </ul>
    </li>
  </ul>
  <aside class="notes">
    Ces usages illustrent pourquoi toutes les bases ne se valent pas :  
    le choix dÃ©pend du mÃ©tier, du besoin de cohÃ©rence, de disponibilitÃ©, et des contraintes rÃ©seau.  
    CAP est un outil d'orientation, pas une rÃ¨gle rigide.
  </aside>
</section>


<section>
  <h2>ğŸ”— Sources</h2>
  <ul>
    <li><a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank">Wikipedia - CAP Theorem</a></li>
    <li><a href="https://code-garage.com/blog/comprendre-le-theoreme-cap" target="_blank">Comprendre le CAP theorem</a></li>
    <li><a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/" target="_blank">CAP Twelve Years Later (InfoQ)</a></li>
    <li><a href="https://aws.amazon.com/nosql/" target="_blank">AWS - NoSQL et CAP</a></li>
  </ul>
  <aside class="notes">
    Ces ressources approfondissent les compromis concrets du CAP dans des cas industriels rÃ©els.
  </aside>
</section>

<section>
  <h2>Consistance Ã©ventuelle & Idempotence</h2>
  <ul>
    <li><strong>Consistance Ã©ventuelle</strong> : Ã©tat convergent Ã  terme</li>
    <li><strong>Idempotence</strong> : un appel rÃ©pÃ©tÃ© ne change pas le rÃ©sultat</li>
  </ul>
  <aside class="notes">
    Ces propriÃ©tÃ©s sont essentielles dans les architectures tolÃ©rantes aux pannes ou asynchrones.
  </aside>
</section>

<!-- section>
  <h2>ğŸš« ThÃ©orÃ¨me de FLP</h2>
  <ul>
    <li>Dans un systÃ¨me distribuÃ© <strong>asynchrone</strong> oÃ¹ un processus peut Ã©chouer,</li>
    <li>Il est <strong>impossible</strong> de garantir qu'un protocole atteindra toujours un consensus,</li>
    <li>mÃªme avec des canaux fiables.</li>
  </ul>
  <aside class="notes">
    Le thÃ©orÃ¨me FLP (1985) montre que le consensus est impossible Ã  garantir dans un systÃ¨me totalement asynchrone avec pannes possibles.  
    Cela explique pourquoi les systÃ¨mes comme Paxos ou Raft sont complexes ou probabilistes.
  </aside>
</section -->

<!-- section>
  <h2>â± ThÃ©orÃ¨me de Lamport</h2>
  <ul>
    <li>Pas d'horloge globale dans un systÃ¨me distribuÃ©</li>
    <li>Mais possibilitÃ© de dÃ©finir un <strong>ordre logique</strong> entre Ã©vÃ©nements</li>
    <li><code>A â†’ B</code> signifie que A se produit avant B</li>
  </ul>
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Lamport%27s_logical_clocks.svg/480px-Lamport%27s_logical_clocks.svg.png" alt="Lamport Clock" style="max-height: 250px;" />
  <aside class="notes">
    Dans un systÃ¨me distribuÃ©, il n'y a pas de temps universel.  
    L'algorithme de Lamport attribue des timestamps logiques pour ordonner les Ã©vÃ©nements.  
    Base des CRDT, des systÃ¨mes Ã  journal distribuÃ©, etc.
  </aside>
</section -->

<section>
  <h2>âš–ï¸ ThÃ©orÃ¨me PACELC</h2>
  <ul>
    <li>ComplÃ¨te le CAP : si Partition, choix entre **Availability** ou **Consistency**</li>
    <li>Sinon (Else), choix entre **Latency** ou **Consistency**</li>
    <li>Formule : <strong>PACELC</strong> = <code>if P then A or C; else L or C</code></li>
  </ul>
  <aside class="notes">
    PACELC ajoute une dimension : mÃªme sans partition, les bases doivent arbitrer entre latence et cohÃ©rence.  
    C'est un modÃ¨le plus rÃ©aliste pour les bases modernes comme DynamoDB ou CosmosDB.
  </aside>
</section>

<section>
  <h2>ğŸ§ª Exemples PACELC</h2>
  <ul>
    <li><strong>DynamoDB</strong> : PA/EL (disponible mÃªme en partition, optimisÃ© pour latence)</li>
    <li><strong>BigTable</strong> : PC/EC (cohÃ©rence forte, quitte Ã  ralentir)</li>
    <li><strong>Cassandra</strong> : PA/EL (rÃ©plication et latence faible)</li>
  </ul>
  <aside class="notes">
    Dynamo et Cassandra privilÃ©gient la rapiditÃ© mÃªme en cas d'incohÃ©rence temporaire.  
    BigTable, au contraire, prÃ©fÃ¨re garantir des lectures cohÃ©rentes.  
    Le choix PACELC influence la conception applicative.
  </aside>
</section>

<!-- section>
  <h2>ğŸ“š SynthÃ¨se pÃ©dagogique</h2>
  <table>
    <thead>
      <tr>
        <th>ThÃ©orÃ¨me</th>
        <th>Pertinence pÃ©dagogique</th>
        <th>IntÃ©rÃªt pratique</th>
        <th>Inclusion recommandÃ©e</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>FLP</td>
        <td>Moyenne</td>
        <td>Faible Ã  moyenne</td>
        <td>ğŸŒ— 1 slide max, optionnel</td>
      </tr>
      <tr>
        <td>Lamport</td>
        <td>Haute</td>
        <td>Haute</td>
        <td>âœ… Oui, simple version</td>
      </tr>
      <tr>
        <td>PACELC</td>
        <td>Haute</td>
        <td>Haute</td>
        <td>âœ… Oui, complÃ©ment CAP</td>
      </tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau aide Ã  dÃ©cider quels concepts approfondir ou simplement mentionner selon le temps, les objectifs et le niveau des Ã©tudiants.
  </aside>
</section -->

<section>
  <h2>ğŸ“‹ CAP vs PACELC</h2>
  <table>
    <thead>
      <tr><th>ModÃ¨le</th><th>Partition</th><th>Sans Partition</th><th>Avantage</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>CAP</strong></td>
        <td>Choix entre <strong>Availability</strong> ou <strong>Consistency</strong></td>
        <td>Non dÃ©fini</td>
        <td>Simple, fondamental</td>
      </tr>
      <tr>
        <td><strong>PACELC</strong></td>
        <td>Choix entre <strong>Availability</strong> ou <strong>Consistency</strong></td>
        <td>Choix entre <strong>Latency</strong> ou <strong>Consistency</strong></td>
        <td>Plus rÃ©aliste en pratique</td>
      </tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau montre que PACELC est une extension utile de CAP :  
    il ajoute la dimension de latence pour les cas sans partition, ce qui reflÃ¨te mieux les compromis actuels dans les bases distribuÃ©es.
  </aside>
</section>

<section>
  <h2>âš–ï¸ ACID vs BASE</h2>
  <ul>
    <li><strong>ACID</strong> : modÃ¨le traditionnel pour bases relationnelles</li>
    <li><strong>BASE</strong> : approche plus souple, adaptÃ©e aux bases distribuÃ©es NoSQL</li>
  </ul>
  <aside class="notes">
    Ces deux modÃ¨les dÃ©finissent comment les systÃ¨mes gÃ¨rent la cohÃ©rence et la fiabilitÃ© des transactions.  
    ACID est strict, BASE est tolÃ©rant : Ã  chaque besoin son modÃ¨le.
  </aside>
</section>

<section>
  <h2>ğŸ”’ ModÃ¨le ACID</h2>
  <ul>
    <li><strong>Atomicity</strong> : tout ou rien</li>
    <li><strong>Consistency</strong> : Ã©tat valide avant/aprÃ¨s la transaction</li>
    <li><strong>Isolation</strong> : pas d'interfÃ©rence entre transactions</li>
    <li><strong>Durability</strong> : une fois validÃ©e, la transaction est persistÃ©e</li>
  </ul>
  <aside class="notes">
    ACID est conÃ§u pour la fiabilitÃ© : trÃ¨s utile pour les systÃ¨mes critiques comme la banque, la facturation.  
    Il s'appuie sur un contrÃ´le transactionnel fort.
  </aside>
</section>

<section>
  <h2>ACID - Avantages et limites</h2>
  <ul>
    <li><strong>âœ… Avantages :</strong> sÃ©curitÃ© des donnÃ©es, cohÃ©rence garantie</li>
    <li><strong>âš ï¸ InconvÃ©nients :</strong> faible scalabilitÃ©, complexitÃ© en distribution</li>
    <li><strong>ğŸ“Œ Bases concernÃ©es :</strong> MySQL, PostgreSQL, Oracle, SQLite</li>
  </ul>
  <aside class="notes">
    Les bases ACID excellent sur un seul nÅ“ud, mais se complexifient fortement en environnement distribuÃ©.  
    Elles sont nÃ©anmoins indispensables dans des cas comme les paiements ou l'ERP.
  </aside>
</section>

<section>
  <h2>ğŸŒŠ ModÃ¨le BASE</h2>
  <ul>
    <li><strong>Basically Available</strong> : le systÃ¨me rÃ©pond toujours, mÃªme partiellement</li>
    <li><strong>Soft state</strong> : l'Ã©tat peut changer sans nouvelle Ã©criture</li>
    <li><strong>Eventual consistency</strong> : la cohÃ©rence est atteinte Ã  terme</li>
  </ul>
  <aside class="notes">
    BASE est une approche plus souple, pensÃ©e pour les systÃ¨mes distribuÃ©s massivement parallÃ¨les.  
    Elle accepte des incohÃ©rences temporaires pour garantir disponibilitÃ© et scalabilitÃ©.
  </aside>
</section>

<section>
  <h2>BASE - Avantages et limites</h2>
  <ul>
    <li><strong>âœ… Avantages :</strong> haute disponibilitÃ©, performance, tolÃ©rance rÃ©seau</li>
    <li><strong>âš ï¸ InconvÃ©nients :</strong> incohÃ©rences temporaires, gestion des conflits</li>
    <li><strong>ğŸ“Œ Bases concernÃ©es :</strong> Cassandra, DynamoDB, CouchDB, Riak</li>
  </ul>
  <aside class="notes">
    Les bases BASE sont adaptÃ©es Ã  des systÃ¨mes globalement distribuÃ©s, Ã  forte volumÃ©trie : rÃ©seaux sociaux, logs, IoT, etc.  
    La cohÃ©rence Ã©ventuelle demande une logique applicative robuste.
  </aside>
</section>

<section>
  <h2>ğŸ“Š ACID vs BASE</h2>
  <table>
    <thead><tr><th>PropriÃ©tÃ©</th><th>ACID</th><th>BASE</th></tr></thead>
    <tbody>
      <tr><td>DisponibilitÃ©</td><td>Secondaire</td><td>Prioritaire</td></tr>
      <tr><td>CohÃ©rence</td><td>Forte</td><td>Ã‰ventuelle</td></tr>
      <tr><td>Partition tolerance</td><td>Faible</td><td>Essentielle</td></tr>
      <tr><td>Performance</td><td>Stable</td><td>OptimisÃ©e</td></tr>
      <tr><td>Cas typique</td><td>Bancaire, ERP</td><td>Web, Big Data</td></tr>
    </tbody>
  </table>
  <aside class="notes">
    Ce tableau aide Ã  choisir la bonne approche selon le contexte mÃ©tier.  
    ACID = rigueur, BASE = scalabilitÃ©. Le choix n'est pas technique, il est fonctionnel.
  </aside>
</section>

<section>
  <h2>ğŸ”— Sources</h2>
  <ul>
    <li><a href="https://en.wikipedia.org/wiki/ACID" target="_blank">Wikipedia - ACID</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Eventual_consistency" target="_blank">Wikipedia - Eventual Consistency</a></li>
    <li><a href="https://www.infoq.com/articles/base-an-acid-alternative/" target="_blank">InfoQ - BASE: An ACID Alternative</a></li>
    <li><a href="https://martinfowler.com/articles/nosql-intro.html" target="_blank">Martin Fowler - NoSQL Intro</a></li>
  </ul>
  <aside class="notes">
    Vous pouvez approfondir la thÃ©orie et les cas pratiques de BASE et ACID Ã  travers ces articles.  
    Martin Fowler donne aussi un bon aperÃ§u des implications dans les architectures NoSQL.
  </aside>
</section>
