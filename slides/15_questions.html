<section
    data-background-image="/public/backgrounds/questions.png"
    data-background-opacity="0.9" 
    data-background-size="cover">
  <h1>Questions ?</h1>
  <p>Quelles sont vos questions sur les architectures logicielles ?</p> 
  <p>Quelles sont vos r√©flexions sur les architectures monolithiques et distribu√©es ?</p>
</section>

<section>
  <h3>üß± 1. Monolithe vs Mainframe</h3>
  <ul>
    <li>Un monolithe, c'est forc√©ment une vieille application sur un mainframe ?</li>
    <li>Un monolithe ne peut pas √™tre moderne ?</li>
    <li>Si une application est monolithique, cela veut dire qu'elle ne peut tourner que sur un seul ordinateur ?</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Non, un monolithe peut √™tre d√©velopp√© aujourd'hui avec des technos modernes. Ce n'est pas li√© aux mainframes.</li>
      <li>Un monolithe peut √™tre propre, performant et maintenable. Ce n'est pas un synonyme d'application obsol√®te.</li>
      <li>Une application monolithique peut √™tre d√©ploy√©e sur plusieurs machines, m√™me si elle reste un seul bloc logiciel.</li>
    </ul>
  </aside>
</section>

<section>
  <h3>üß© 2. Monolithe vs Microservices</h3>
  <ul>
    <li>Si une application est divis√©e en plusieurs fichiers ou modules, est-ce qu'elle n'est plus un monolithe ?</li>
    <li>Est-ce qu'on est oblig√© d'avoir plusieurs d√©p√¥ts de code pour faire une architecture microservices ?</li>
    <li>Est-ce que les microservices sont toujours plus performants qu'un monolithe ?</li>
    <li>Est-ce que c'est mieux de toujours d√©couper son application en microservices d√®s le d√©but ?</li>
    <li>Si je peux red√©marrer un service sans toucher au reste de l'application, est-ce que c'est forc√©ment un microservice ?</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Non, un monolithe peut √™tre bien structur√© en modules sans √™tre distribu√© ou microservices.</li>
      <li>Non, on peut avoir tous les services dans un monorepo. Ce n'est pas une obligation technique.</li>
      <li>Pas toujours : plus de complexit√©, de communication r√©seau, de latence possible. Ce n'est pas automatique.</li>
      <li>Pas n√©cessairement : pour un petit projet ou un MVP, un monolithe est souvent plus simple √† g√©rer.</li>
      <li>Non : ce crit√®re est typique, mais ce n'est pas suffisant pour d√©finir un microservice.</li>
    </ul>
  </aside>
</section>

<section>
  <h3>üß™ 3. Microservices vs SOA</h3>
  <ul>
    <li>Si mes services communiquent entre eux, est-ce qu'on est automatiquement dans une architecture SOA ?</li>
    <li>Peut-on avoir une architecture microservices sans architecture SOA ?</li>
    <li>Est-ce que microservices et SOA, c'est la m√™me chose ?</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Non, la communication entre services ne suffit pas √† d√©finir SOA. L'approche, les contrats et la gouvernance comptent aussi.</li>
      <li>Oui, les microservices sont une √©volution de SOA mais avec une granularit√© plus fine, des d√©ploiements ind√©pendants, etc.</li>
      <li>Non, ce sont deux concepts diff√©rents, m√™me s'ils sont li√©s. Les microservices sont une approche plus l√©g√®re et d√©centralis√©e.</li>
    </ul>
  </aside>
</section>

<section>
  <h3>‚òÅÔ∏è 4. Microservices et d√©ploiement</h3>
  <ul>
    <li>Est-ce qu'une architecture microservices doit forc√©ment √™tre d√©ploy√©e sur le cloud ?</li>
    <li>Peut-on faire une architecture microservices sur un seul serveur ?</li>
    <li>Est-ce qu'une application est "distribu√©e" uniquement si elle tourne sur plusieurs serveurs ?</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Non, on peut faire du microservices en local ou on-premise. Le cloud n'est pas obligatoire.</li>
      <li>Oui, on peut faire tourner plusieurs services sur un m√™me serveur physique, voire dans le m√™me container au d√©but.</li>
      <li>Non, plusieurs processus interconnect√©s suffisent, m√™me sur une seule machine.</li>
    </ul>
  </aside>
</section>

<section>
  <h3>üßÆ 5. MVC, n-tiers et structure de code</h3>
  <ul>
    <li>Une application avec une architecture en couches (MVC ou n-tiers) est-elle forc√©ment distribu√©e ?</li>
    <li>Le mod√®le MVC ne s'utilise que dans les architectures n-tiers ?</li>
    <li>Si j'utilise un framework moderne, est-ce que je fais automatiquement une architecture n-tiers ?</li>
    <li>Est-ce qu'une application MVC est forc√©ment web ?</li>
    <li>Est-ce que le fait d'avoir une partie ‚Äúvue‚Äù dans le navigateur et une ‚Äúlogique‚Äù sur un serveur rend l'application distribu√©e ?</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Non, MVC et n-tiers sont des patterns de structuration logique, pas de distribution physique.</li>
      <li>Non, on peut appliquer MVC en local, dans une appli bureau par exemple.</li>
      <li>Non, le framework ne dicte pas l'architecture physique, juste la structure logique.</li>
      <li>Non, MVC est aussi utilis√© pour des applis desktop ou mobiles.</li>
      <li>Oui, techniquement, c'est une forme simple d'architecture distribu√©e (client-serveur).</li>
    </ul>
  </aside>
</section>

<section>
  <h3>üåç 6. Application distribu√©e ou pas ?</h3>
  <ul>
    <li>Une application distribu√©e, c'est juste une appli qui communique avec un serveur ?</li>
    <li>Est-ce qu'une application distribu√©e tourne forc√©ment sur plusieurs machines ?</li>
    <li>Est-ce que ‚Äúapplication distribu√©e‚Äù veut dire ‚Äúmicroservices‚Äù ?</li>
    <li>Est-ce que l'utilisateur d'une application distribu√©e interagit avec plusieurs applications diff√©rentes ?</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>En partie, oui. C'est le cas typique du client-serveur. Mais ce n'est pas l'unique forme de distribution.</li>
      <li>Non, plusieurs processus interconnect√©s suffisent, m√™me sur une seule machine.</li>
      <li>Non, une application distribu√©e peut √™tre un monolithe d√©ploy√© sur plusieurs n≈ìuds, ou une appli client-serveur classique.</li>
      <li>Non, elle peut percevoir un tout coh√©rent m√™me si l'architecture est distribu√©e en interne.</li>
    </ul>
  </aside>
</section>

<section>
  <h3>üë• 7. Organisation des √©quipes et architecture</h3>
  <ul>
    <li>Si plusieurs √©quipes travaillent sur le m√™me projet, est-ce qu'il faut forc√©ment passer √† une architecture microservices ?</li>
    <li>Avoir plusieurs d√©veloppeurs, √ßa veut dire qu'on ne peut pas rester en monolithe ?</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Non, on peut tr√®s bien organiser le travail sur un monolithe en modules ou sous-projets bien s√©par√©s.</li>
      <li>Non, ce n'est pas le nombre de d√©veloppeurs qui dicte l'architecture, mais les besoins m√©tiers, la scalabilit√©, la maintenabilit√©‚Ä¶</li>
    </ul>
  </aside>
</section>
<section>
  <h3>üîß 8. Outils et technologies</h3>
  <ul>
    <li>Est-ce qu'on doit utiliser des outils sp√©cifiques pour faire du microservices ?</li>
    <li>Est-ce que les microservices sont r√©serv√©s √† certaines technologies ?</li>
    <li>Est-ce que le cloud est obligatoire pour faire du microservices ?</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Non, on peut utiliser des outils vari√©s, mais certains facilitent la gestion des microservices.</li>
      <li>Non, on peut faire du microservices avec n'importe quelle technologie, m√™me des langages moins courants.</li>
      <li>Non, le cloud est un choix, pas une obligation. On peut faire du microservices sur site.</li>
    </ul>
  </aside>
</section>
<section>
  <h3>üîí 9. S√©curit√©</h3>
  <ul>
    <li>Est-ce que les microservices sont plus s√©curis√©s qu'un monolithe ?</li>
    <li>Est-ce que la s√©curit√© est plus complexe dans une architecture distribu√©e ?</li>
    <li>Est-ce que le fait d'avoir plusieurs services rend l'application moins s√©curis√©e ?</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Pas forc√©ment, la s√©curit√© d√©pend de la mise en ≈ìuvre, pas de l'architecture.</li>
      <li>Oui, la gestion des acc√®s, des communications et des donn√©es est plus complexe.</li>
      <li>Non, mais il faut bien g√©rer les acc√®s et les communications entre services.</li>
    </ul>
  </aside>
</section>

<section
         data-background-image="/public/backgrounds/postits.jpg"
         data-background-size="cover"
         data-background-opacity="0.9"
         style="color: navy;">
  <h2 style="color: navy;">A vous de vous exprimer :</h2>
  <p>Quelles notions ou mots-clefs vous viennent quand on √©voque les applications distribu√©es?</p> 
  <p>Vous pouvez vous r√©partir en 4 groupes et vous avez 5 minutes</p>
  <p>Le but est d'√©crire vos id√©es sur des post-its puis nous les trierons, regrouperons et √©changerons sur celles-ci.</p>
</section>

<!-- Slide 1: Titre -->
<section>
  <h2>Applications Distribu√©es vs Microservices</h2>
  <p>Comparaison des deux approches architecturales</p>
  <aside class="notes">
    Cette pr√©sentation d√©taille les diff√©rences fondamentales entre applications distribu√©es et microservices, deux approches visant toutes deux √† g√©rer la r√©partition des composants sur un r√©seau, mais avec des objectifs et des contraintes distincts en termes de d√©couplage, d'autonomie et de gouvernance technique.
  </aside>
</section>

<!-- Slide 2: Similitudes -->
<section>
  <h2>Similitudes</h2>
  <ul>
    <li>Distribution : r√©partition de composants sur diff√©rentes machines ou environnements.</li>
    <li>Communication r√©seau : API REST, messagerie, RPC, etc.</li>
    <li>Objectifs : scalabilit√©, disponibilit√© et r√©silience.</li>
    <li>D√©couplage : composants faiblement coupl√©s.</li>
  </ul>
  <aside class="notes">
    Les deux mod√®les ont en commun l‚Äôusage d‚Äôun r√©seau pour faire communiquer des modules : par exemple, une application de e‚Äëcommerce peut r√©partir le front-end sur un CDN et les services de paiement sur des VM d√©di√©es. Que ce soit via REST ou via un bus de messages Kafka, l‚Äôenjeu est de pouvoir faire √©voluer ind√©pendamment chaque composant afin de g√©rer la mont√©e en charge et d‚Äôassurer une tol√©rance aux pannes.
  </aside>
</section>

<!-- Slide 3: Port√©e et d√©finition -->
<section>
  <h2>Port√©e et d√©finition</h2>
  <p>
    <strong>Applications distribu√©es</strong> : concept g√©n√©ral o√π les composants s‚Äôex√©cutent sur plusieurs machines.
  </p>
  <p>
    <strong>Microservices</strong> : sous-ensemble avec principes de conception pr√©cis.
  </p>
  <aside class="notes">
    Les applications distribu√©es existent depuis les ann√©es 80, couvrant des architectures client-serveur classiques ou des grilles de calcul Scyld Beowulf. Les microservices ont √©merg√© vers 2012 chez Amazon et Netflix, avec l‚Äôobjectif de d√©couper les fonctions m√©tiers en petits services d√©ployables et testables ind√©pendamment.
  </aside>
</section>

<!-- Slide 4: Granularit√© et autonomie -->
<section>
  <h2>Granularit√© et autonomie</h2>
  <ul>
    <li>Applications distribu√©es¬†: composants de taille variable, parfois monolithiques.</li>
    <li>Microservices¬†: services petits, centr√©s sur une fonctionnalit√© unique, forte coh√©sion.</li>
  </ul>
  <aside class="notes">
    Dans une application distribu√©e traditionnelle, un service peut g√©rer plusieurs domaines (par exemple facturation et gestion des utilisateurs). En microservices, chaque service ne fait qu‚Äôune seule t√¢che : un service ¬´¬†facturation¬†¬ª g√®re uniquement les transactions, tandis qu‚Äôun autre service ¬´¬†authentification¬†¬ª s‚Äôoccupe de la s√©curit√© et des sessions, ce qui permet des √©volutions et des tests cibl√©s.
  </aside>
</section>

<!-- Slide 5: Ind√©pendance technologique -->
<section>
  <h2>Ind√©pendance technologique</h2>
  <ul>
    <li>Applications distribu√©es¬†: technologie homog√®ne possible.</li>
    <li>Microservices¬†: polyglot programming, chaque service choisit la meilleure technologie.</li>
  </ul>
  <aside class="notes">
    Un cluster d‚Äôapplication Java EE d√©ploy√© sur plusieurs serveurs est un exemple d‚Äôarchitecture distribu√©e homog√®ne. √Ä l‚Äôinverse, un syst√®me reposant sur microservices peut combiner des APIs en Go pour la performance r√©seau, des services en Python pour l‚Äôanalyse de donn√©es et un service Node.js pour le front, optimisant ainsi chaque composant pour son cas d‚Äôusage.
  </aside>
</section>

<!-- Slide 6: D√©ploiement -->
<section>
  <h2>D√©ploiement</h2>
  <ul>
    <li>Applications distribu√©es¬†: d√©ploiement souvent coordonn√©.</li>
    <li>Microservices¬†: d√©ploiement ind√©pendant par service.</li>
  </ul>
  <aside class="notes">
    Dans un d√©ploiement coordonn√©, l‚Äôensemble des serveurs doit √™tre mis √† jour simultan√©ment, provoquant parfois des coupures de service. Les microservices utilisent des pipelines CI/CD distincts, par exemple un service de notification peut √™tre mis √† jour sans impacter le service de catalogue, garantissant un d√©ploiement continu et sans interruption globale.
  </aside>
</section>

<!-- Slide 7: Gouvernance des donn√©es -->
<section>
  <h2>Gouvernance des donn√©es</h2>
  <ul>
    <li>Applications distribu√©es¬†: base de donn√©es centrale partag√©e.</li>
    <li>Microservices¬†: base de donn√©es par service, d√©centralisation des donn√©es.</li>
  </ul>
  <aside class="notes">
    Un ERP SAP classique utilise une base de donn√©es unique pour l‚Äôensemble des modules, ce qui cr√©e un point de passage oblig√© pour toutes les transactions. En microservices, chaque service a sa propre BDD (par exemple un service d‚Äôinventaire sur PostgreSQL et un service de statistiques sur MongoDB), am√©liorant l‚Äôisolation mais n√©cessitant la gestion de transactions distribu√©es lors d‚Äôop√©rations complexes.
  </aside>
</section>

<!-- Slide 8: Relation entre les deux concepts -->
<section>
  <h2>Relation entre les deux concepts</h2>
  <p>
    Les microservices sont une forme sp√©cifique d‚Äôapplications distribu√©es¬†: le "quoi" vs le "comment".
  </p>
  <ul>
    <li>Applications distribu√©es¬†: syst√®me r√©parti sur un r√©seau.</li>
    <li>Microservices¬†: m√©thode pr√©cise pour concevoir un syst√®me distribu√©.</li>
  </ul>
  <aside class="notes">
    Les microservices appliquent des r√®gles strictes¬†: d√©ploiement ind√©pendant, base de donn√©es par service, versioning asynchrone et communication l√©g√®re. Prenons l‚Äôexemple d‚Äôun CMS WordPress multisite¬†: il peut √™tre r√©parti sur plusieurs serveurs web pour g√©rer la charge (applications distribu√©es), mais il partage une seule base MySQL et ne propose pas de d√©ploiement ind√©pendant de chaque module¬†: c‚Äôest un anti-pattern vis-√†-vis des microservices.
  </aside>
</section>

<!-- Slide 9: R√©sum√© -->
<section>
  <h2>R√©sum√©</h2>
  <p>
    Les microservices constituent une √©volution sp√©cialis√©e des applications distribu√©es,
    avec des principes architecturaux stricts pour r√©pondre aux d√©fis modernes.
  </p>
  <aside class="notes">
    En conclusion, adoptez les microservices pour des syst√®mes requ√©rant une forte autonomie et une scalabilit√© granulaire. Pour des projets plus petits ou moins √©volutifs, une application distribu√©e classique reste une solution robuste et plus simple √† g√©rer.
  </aside>
</section>


<!-- Slide 1: Titre -->
<section>
  <h2>Concepts connexes aux Applications Distribu√©es et Microservices</h2>
  <p>Panorama des principaux paradigmes architecturaux associ√©s</p>
  <aside class="notes">
    <ul>
      <li>Ces paradigmes peuvent coexister dans un m√™me syst√®me et requi√®rent une gouvernance adapt√©e pour r√©partir clairement les responsabilit√©s entre √©quipes.</li>
      <li>Chaque mod√®le pr√©sente des compromis en termes de performance : latence r√©seau, capacit√© de mont√©e en charge et tol√©rance aux pannes doivent √™tre √©valu√©es pr√©cis√©ment.</li>
      <li>Le co√ªt global d√©pend de la granularit√© de la facturation, de la gestion d‚Äôinfrastructure et des licences logicielles associ√©es.</li>
    </ul>
  </aside>
</section>

<!-- Slide 2: Architecture Orient√©e Services (SOA) -->
<section>
  <h2>Architecture Orient√©e Services (SOA)</h2>
  <p>Similitudes avec les microservices :</p>
  <ul>
    <li>Services autonomes via interfaces standards (SOAP/WSDL)</li>
    <li>D√©couplage fonctionnel des composants</li>
  </ul>
  <p>Diff√©rences :</p>
  <ul>
    <li>ESB central pour routage et transformation</li>
    <li>Services volumineux (100-300 Mo) vs microservices (10-50 Mo)</li>
    <li>R√©utilisation √† l‚Äô√©chelle entreprise vs ind√©pendance d‚Äô√©quipe</li>
    <li>Gouvernance centralis√©e des contrats et versions</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Un ESB comme MuleSoft centralise le routage et la transformation des messages SOAP et JSON, garantissant l‚Äôint√©grit√© des √©changes entre services.</li>
      <li>Les services SOA peuvent d√©passer 200 Mo car ils int√®grent plusieurs fonctions m√©tier, ce qui ralentit les d√©ploiements et augmente la complexit√© des mises √† jour.</li>
      <li>La r√©utilisation d‚Äôartefacts √† l‚Äô√©chelle entreprise facilite l‚Äôhomog√©n√©it√©, mais limite l‚Äôautonomie des √©quipes sur le cycle de vie des services.</li>
      <li>Les contrats de service sont g√©r√©s dans un registre central, n√©cessitant une gouvernance stricte pour maintenir la compatibilit√© ascendante.</li>
    </ul>
  </aside>
</section>

<!-- Slide 3: Serverless / FaaS -->
<section>
  <h2>Serverless / FaaS</h2>
  <p>Similitudes avec les microservices :</p>
  <ul>
    <li>Unit√©s fonctionnelles ind√©pendantes (fonctions)</li>
    <li>Scalabilit√© automatique</li>
  </ul>
  <p>Diff√©rences :</p>
  <ul>
    <li>Granularit√© tr√®s fine : fonctions plut√¥t que services</li>
    <li>Mod√®le √©v√©nementiel (trigger par √©v√©nements)</li>
    <li>Infrastructure enti√®rement g√©r√©e par le fournisseur</li>
    <li>Stateless obligatoire</li>
    <li>Facturation √† la milliseconde</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>AWS Lambda engage un <em>cold start</em> pouvant ajouter 200 √† 500 ms de latence, puis bascule en warm start pour les requ√™tes suivantes.</li>
      <li>La facturation √† la milliseconde incite √† optimiser le code pour minimiser la dur√©e d‚Äôex√©cution et r√©duire les co√ªts.</li>
      <li>L‚Äôabsence d‚Äô√©tat persistant dans la fonction n√©cessite d‚Äôexternaliser les sessions et les donn√©es interm√©diaires vers des services comme DynamoDB ou Redis.</li>
      <li>Le mod√®le √©v√©nementiel d√©clenche les fonctions sur des √©v√©nements vari√©s : requ√™tes HTTP, messages en file d‚Äôattente ou minuteries planifi√©es.</li>
    </ul>
  </aside>
</section>

<!-- Slide 4: Syst√®mes distribu√©s / Calcul distribu√© -->
<section>
  <h2>Syst√®mes distribu√©s / Calcul distribu√©</h2>
  <ul>
    <li>Algorithmes de consensus : Paxos, Raft</li>
    <li>Th√©or√®me CAP : Consistency, Availability, Partition tolerance</li>
    <li>Exemples : clusters Hadoop, simulations HPC avec MPI</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Paxos et Raft sont des protocoles de consensus qui synchronisent un journal de transactions entre plusieurs n≈ìuds en garantissant l‚Äôaccord m√™me en cas de panne.</li>
      <li>Le th√©or√®me CAP stipule qu‚Äôun syst√®me distribu√© ne peut garantir simultan√©ment coh√©rence forte, disponibilit√© et tol√©rance aux partitions r√©seau.</li>
      <li>Hadoop MapReduce distribue les t√¢ches de traitement de donn√©es massives sur des clusters de serveurs, appliquant les principes CAP et consensus pour coordonner les n≈ìuds.</li>
      <li>MPI (Message Passing Interface) est utilis√© dans les supercalculateurs pour ex√©cuter des simulations parall√®les n√©cessitant une communication fine entre processus.</li>
    </ul>
  </aside>
</section>

<!-- Slide 5: Conteneurisation et Orchestration -->
<section>
  <h2>Conteneurisation & Orchestration</h2>
  <p>Relation avec les microservices :</p>
  <ul>
    <li>Docker : conteneurs l√©gers pour isolation</li>
    <li>Kubernetes : pods, services, d√©ploiements et scaling</li>
    <li>Helm : gestion des charts pour versioning</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Docker cr√©e des images en couches, assurant que chaque modification du code ou de la configuration g√©n√®re un nouvel identifiant d‚Äôimage.</li>
      <li>Kubernetes organise les conteneurs en¬†pods et g√®re automatiquement leur disponibilit√© avec des ReplicaSets et des probes de sant√©.</li>
      <li>Les d√©ploiements Kubernetes permettent des mises √† jour progressives (<em>rolling updates</em>) sans interruption de service.</li>
      <li>Helm charts encapsulent les manifestes YAML et simplifient le d√©ploiement et la gestion des versions de l‚Äôapplication.</li>
    </ul>
  </aside>
</section>

<!-- Slide 6: Architecture Event-Driven -->
<section>
  <h2>Architecture Event-Driven</h2>
  <p>Similitudes avec les applications distribu√©es :</p>
  <ul>
    <li>Asynchrone via file d‚Äô√©v√©nements</li>
    <li>D√©couplage temporel des producteurs et consommateurs</li>
  </ul>
  <p>Diff√©rences :</p>
  <ul>
    <li>Focus sur streams d‚Äô√©v√©nements plut√¥t que requ√™tes/r√©ponses</li>
    <li>Peut √™tre d√©ploy√©e en monolithe ou microservices</li>
    <li>Pattern CQRS pour s√©parer lecture et √©criture</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Kafka stocke les √©v√©nements dans des topics partitionn√©s, o√π chaque message conserve son offset pour permettre la relecture.</li>
      <li>RabbitMQ utilise des exchanges et des queues pour router les messages selon des r√®gles de binding flexibles.</li>
      <li>Le pattern CQRS s√©pare les commandes (√©criture) des requ√™tes (lecture), entra√Ænant souvent une coh√©rence √©ventuelle lorsque les mises √† jour se propagent entre mod√®les.</li>
      <li>Ce mod√®le convient aux flux de donn√©es en temps r√©el, comme les tableaux de bord financiers ou les syst√®mes de notifications.</li>
    </ul>
  </aside>
</section>

<!-- Slide 7: Mesh App and Service Architecture (MASA) -->
<section>
  <h2>Mesh App & Service Architecture (MASA)</h2>
  <p>Similitudes :</p>
  <ul>
    <li>Services ind√©pendants interconnect√©s dans un maillage</li>
    <li>D√©couplage fonctionnel</li>
  </ul>
  <p>Diff√©rences :</p>
  <ul>
    <li>Inclut monolithes et interfaces utilisateurs</li>
    <li>Prend en compte edge computing et exp√©rience UX</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Gartner d√©finit MASA comme une extension du service mesh, int√©grant √©galement les frontaux web et les fonctions edge pour une exp√©rience unifi√©e.</li>
      <li>Ce mod√®le permet d‚Äôorchestrer √† la fois des microservices backend et des applications monolithiques h√©rit√©es sans refonte compl√®te.</li>
      <li>Il facilite la personnalisation en temps r√©el, par exemple via un CDN edge qui adapte le contenu selon le profil utilisateur.</li>
    </ul>
  </aside>
</section>

<!-- Slide 8: API Gateway / Backend for Frontend (BFF) -->
<section>
  <h2>API Gateway / Backend for Frontend (BFF)</h2>
  <p>Relation :</p>
  <ul>
    <li>AWS API Gateway, Kong : gestion des points d‚Äôentr√©e API</li>
    <li>BFF : backend sp√©cifique √† chaque type de client</li>
    <li>R√©duction des allers-retours et adaptation du payload</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Une API Gateway centralise l‚Äôauthentification, le routage et la limitation de d√©bit avant d‚Äôenvoyer les requ√™tes aux microservices.</li>
      <li>Kong et Apigee proposent des plugins pour ajouter du logging, du monitoring et des contr√¥les de s√©curit√© sans modifier le code applicatif.</li>
      <li>Le BFF consiste √† cr√©er un microservice par interface client (mobile, web, IoT) pour pr√©-aggr√©ger les donn√©es et optimiser la bande passante.</li>
    </ul>
  </aside>
</section>

<!-- Slide 9: Monolithes modulaires -->
<section>
  <h2>Monolithes modulaires</h2>
  <p>Diff√©rences :</p>
  <ul>
    <li>Pas de communication r√©seau interne</li>
    <li>D√©ploiement unique et base de donn√©es partag√©e</li>
    <li>Modules d√©coupl√©s mais empaquet√©s ensemble</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Les monolithes modulaires utilisent des <em>bounded contexts</em> pour s√©parer le code tout en restant dans un seul ex√©cutable.</li>
      <li>Ils sont souvent packag√©s sous forme de WAR ou de JAR ex√©cutable, ce qui simplifie la cha√Æne CI/CD.</li>
      <li>Ce mod√®le peut devenir un goulot d‚Äô√©tranglement si la charge augmente ou si de nombreuses √©quipes travaillent simultan√©ment sur le m√™me artefact.</li>
    </ul>
  </aside>
</section>

<!-- Slide 10: Conclusion -->
<section>
  <h2>Conclusion</h2>
  <p>Les architectures distribu√©es et microservices sont compl√©mentaires, mais n√©cessitent une gouvernance adapt√©e.</p>
  <p>Choisissez le mod√®le en fonction des besoins m√©tiers, de la scalabilit√© et de la complexit√©.</p>
  <aside class="notes">
    <ul>
      <li>Les applications distribu√©es offrent une base solide pour r√©partir la charge et garantir la tol√©rance aux pannes gr√¢ce √† une architecture r√©seau.</li>
      <li>Les microservices ajoutent une couche de granularit√© et permettent √† chaque √©quipe de g√©rer son cycle de vie, ses technologies et sa base de donn√©es sp√©cifique.</li>
      <li>Pour un projet √† grande √©chelle avec des √©quipes nombreuses et des besoins de scalabilit√© fine, privil√©giez les microservices.</li>
      <li>Pour des syst√®mes plus simples ou historiques, une architecture distribu√©e classique peut suffire, r√©duisant la complexit√© op√©rationnelle.</li>
      <li>L‚Äôimportant est de d√©finir des r√®gles de gouvernance claires d√®s le d√©part pour √©viter les d√©rives et assurer la coh√©rence globale du syst√®me.</li>
    </ul>
  </aside>
</section>

