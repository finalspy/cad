<section>
  <h1>Domain Driven Design (DDD)</h1>
  <p>Introduction au Domain Driven Design dans le cadre de la conception d'applications distribuÃ©es.</p>
  <aside class="notes">
    <ul>
      <li>Introduction du sujet. DDD permet de mieux aligner la technique avec les besoins mÃ©tier.</li>
    </ul>
  </aside>
</section>
<section>
  <h1>Sommaire</h1>
  <ul>
    <li>Pourquoi DDD ?</li>
    <li>Concepts fondamentaux</li>
    <li>Structure d'un projet DDD</li>
    <li>ModÃ©lisation stratÃ©gique</li>
    <li>ModÃ©lisation tactique</li>
    <li>Exemples concrets</li>
    <li>Conclusion et ouverture</li>
    <li>Ressources & RÃ©fÃ©rences</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>PrÃ©senter le plan. Expliquer la diffÃ©rence entre la modÃ©lisation stratÃ©gique (vue d'ensemble) et tactique (implÃ©mentation).</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Pourquoi Domain Driven Design ?</h1>
  <p>Le DDD permet dâ€™adresser la complexitÃ© des domaines mÃ©tiers avec une architecture logicielle centrÃ©e sur le mÃ©tier.</p>
  <ul>
    <li>Aligner technique et mÃ©tier</li>
    <li>Faciliter la communication</li>
    <li>RÃ©duire la dette technique</li>
    <li>GÃ©rer la complexitÃ© des systÃ¨mes distribuÃ©s</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Insister sur l'importance du langage commun et du dÃ©coupage par responsabilitÃ© mÃ©tier dans les systÃ¨mes complexes.</li>
    </ul>
  </aside>
</section>
<section>
  <h1>Pourquoi Domain-Driven Design ?</h1>
  <p>Un ensemble de pratiques pour aligner le logiciel sur le cÅ“ur mÃ©tier et maÃ®triser la complexitÃ©.</p>
  <ul>
    <li>ğŸ§© GÃ©rer la complexitÃ© des domaines riches</li>
    <li>ğŸ¤ AmÃ©liorer la collaboration mÃ©tierâ€“technique</li>
    <li>âš™ï¸ RÃ©duire la dette technique et le couplage involontaire</li>
    <li>ğŸŒ Faciliter la cohÃ©rence dans les architectures distribuÃ©es</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Insister sur les enjeux des systÃ¨mes distribuÃ©s : multiples Ã©quipes, microservices, transactions partielles.</li>
      <li>Expliquer comment un langage commun (Ubiquitous Language) Ã©vite les malentendus entre dÃ©veloppeurs et experts mÃ©tier.</li>
      <li>Montrer quâ€™un bon dÃ©coupage en bounded contexts limite la propagation des changements et favorise lâ€™autonomie des Ã©quipes.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Ubiquitous Language</h1>
  <p>Le vocabulaire partagÃ© et rigoureux utilisÃ© dans tout le projet, du code aux rÃ©unions.</p>
  <ul>
    <li>ğŸ“– DÃ©crit prÃ©cisÃ©ment les concepts mÃ©tier</li>
    <li>ğŸ”„ UtilisÃ© dans les tests, la documentation et le code</li>
    <li>ğŸ¤“ Ã‰volue avec le domaine et sâ€™adapte aux retours mÃ©tier</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Donner lâ€™exemple dâ€™un â€œOrder â€ vs â€œPurchase â€: mÃªmes mots, sens diffÃ©rents selon le contexte.</li>
      <li>Montrer comment les reviewers de PR vÃ©rifient la cohÃ©rence du langage omniprÃ©sent.</li>
      <li>Avantage : dÃ©tecter tÃ´t les mauvaises comprÃ©hensions avant quâ€™elles nâ€™atterrissent en prod.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Bounded Context</h1>
  <p>FrontiÃ¨re explicite dans laquelle un modÃ¨le et un langage sont cohÃ©rents.</p>
  <ul>
    <li>â†•ï¸ ModÃ¨le et langage propres</li>
    <li>ğŸ”— Interaction via des API/formats convenus</li>
    <li>ğŸ“¦ Context Map documente les relations</li>
  </ul>
  <img src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*CIbJ3VRJb0wxIYchS9PduA.png" alt="Context Map Example" style="width:75%">
  <aside class="notes">
    <ul>
      <li>PrÃ©senter les patterns de relation :  
        <ul>
          <li><strong>Partnership</strong> : deux Ã©quipes coopÃ¨rent Ã©troitement.</li>
          <li><strong>Shared Kernel</strong> : partage dâ€™un sous-modÃ¨le commun.</li>
          <li><strong>Customerâ€“Supplier</strong> : un contexte proveedor dicte le contrat.</li>
          <li><strong>Conformist</strong> : on sâ€™aligne sur le modÃ¨le dâ€™un fournisseur sans nÃ©gociation.</li>
          <li><strong>Anti-Corruption Layer</strong> : adapter/transformer pour Ã©viter la Â« pollution Â» dâ€™un modÃ¨le externe.</li>
        </ul>
      </li>
      <li>Expliquer lâ€™importance de choisir le bon pattern selon le dÃ©coupage organisationnel.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>EntitÃ©s (Entities)</h1>
  <p>Objets dÃ©finis par leur identitÃ©, ayant un cycle de vie et des invariants.</p>
  <ul>
    <li>ğŸ†” IdentitÃ© unique (ID immuable)</li>
    <li>â³ Cycle de vie (crÃ©ation, Ã©volution, suppression)</li>
    <li>ğŸ”’ Invariants mÃ©tier (rÃ¨gles toujours vraies)</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Exemple : <em>Commande</em> avec son ID et son statut ; mÃªme contenu, deux commandes diffÃ¨rent.</li>
      <li>Invariants : date de livraison â‰¥ date de commande, montant total â‰¥ 0.</li>
      <li>Montrer un diagramme UML dâ€™une entitÃ© simple avec attributs et mÃ©thodes mÃ©tier.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Value Objects</h1>
  <p>Objets dÃ©finis par leurs attributs, immuables et sans identitÃ© propre.</p>
  <ul>
    <li>ğŸ¨ Ã‰galitÃ© par valeur (equals)</li>
    <li>ğŸ”’ Immuables pour garantir la cohÃ©rence</li>
    <li>ğŸ“¦ Encapsulent des concepts (p.ex. Adresse, Money)</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Exemple : adresse de livraison. Deux adresses avec mÃªmes champs sont interchangeables.</li>
      <li>Eviter les setters ; recrÃ©er lâ€™objet pour Â« modifier Â» une valeur.</li>
      <li>Avantage performance : caches, partages dâ€™instances identiques.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>AgrÃ©gats (Aggregates)</h1>
  <p>Regroupent des entitÃ©s et des value objects autour dâ€™une racine (Aggregate Root).</p>
  <ul>
    <li>ğŸŒ³ Racine unique contrÃ´lant lâ€™accÃ¨s externe</li>
    <li>ğŸ”— Garantissent les invariants transactionnels</li>
    <li>ğŸ›¡ï¸ Limite de consistance : pas de rÃ©fÃ©rence directe hors agrÃ©gat</li>
  </ul>
  <img src="https://raw.githubusercontent.com/ddd-crew/ddd-starter-modelling-process/main/images/ddd-aggregates.png" alt="Aggregates Diagram" style="width:70%">
  <aside class="notes">
    <ul>
      <li>Montrer comment la racine coordonne la crÃ©ation et les rÃ¨gles (p.ex. ajout de ligne de commande).</li>
      <li>Expliquer la notion de Â« Transactional Boundary Â» : tout dans lâ€™agrÃ©gat est atomique.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Domain Services & Factories & Repositories</h1>
  <p>Composants supports ne tenant pas directement dâ€™Ã©tat Ã  long terme.</p>
  <ul>
    <li>âš™ï¸ <strong>Domain Service</strong> : opÃ©rations mÃ©tier sans entitÃ© propriÃ©taire</li>
    <li>ğŸ­ <strong>Factory</strong> : encapsule la crÃ©ation complexe dâ€™objets</li>
    <li>ğŸ’¾ <strong>Repository</strong> : interface entre le domaine et la persistance</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Domain Service : calcul de remise globale, orchestration de plusieurs agrÃ©gats.</li>
      <li>Factory : crÃ©ation dâ€™un agrÃ©gat avec ID, champs calculÃ©s, rÃ¨gles de construction.</li>
      <li>Repository : expose save(), findById(), findBySpec() ; respecte lâ€™Interface Segregation.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Domain Events</h1>
  <p>Ã‰vÃ©nements immuables dÃ©clenchÃ©s lors de changements significatifs du domaine.</p>
  <ul>
    <li>ğŸ“£ Notifier dâ€™autres contextes ou sous-domaines</li>
    <li>â±ï¸ Souvent utilisÃ©s pour lâ€™asynchronisme et lâ€™Ã©volutivitÃ©</li>
    <li>ğŸ”„ Favorisent la consistance Ã©ventuelle</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Exemple : â€œOrderPaidâ€ publiÃ© aprÃ¨s validation du paiement.</li>
      <li>Patron Pub/Sub : les autres bounded contexts rÃ©agissent pour dÃ©clencher des workflows.</li>
      <li>Attention Ã  la duplication de donnÃ©es et Ã  lâ€™ordonnancement.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>ModÃ©lisation stratÃ©gique dÃ©taillÃ©e</h1>
  <p>DÃ©finir le paysage global avant dâ€™entrer dans le dÃ©tail tactique.</p>
  <ul>
    <li>ğŸ“ Identification des sous-domaines (core, supporting, generic)</li>
    <li>ğŸ—ºï¸ Dessiner la Context Map et choisir les patterns</li>
    <li>ğŸ¤¼â€â™‚ï¸ Organiser les Ã©quipes par contextes indÃ©pendants</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Core Domain : cÅ“ur de la diffÃ©renciation mÃ©tier, mÃ©rite les ressources clÃ©s.</li>
      <li>Supporting Domain : second rÃ´le, souvent externalisable.</li>
      <li>Generic Domain : fonctions transversales (ex. authentification), prÃ©fÃ©rez une solution â€œoff-the-shelfâ€.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>ModÃ©lisation tactique dÃ©taillÃ©e</h1>
  <p>Appliquer les building blocks DDD dans la couche code.</p>
  <ul>
    <li>Identifier les entitÃ©s vs VO</li>
    <li>DÃ©finir les agrÃ©gats et frontiÃ¨res transactionnelles</li>
    <li>Encapsuler la logique mÃ©tier dans services/domain events</li>
    <li>Isoler la persistance via repositories/factories</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Montrer un extrait de code TypeScript pour chaque building block.</li>
      <li>Expliquer le test unitaire par agrÃ©gat en simulant les invariants.</li>
      <li>Illustrer lâ€™injection de dÃ©pendances pour factories et repositories.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Concepts fondamentaux du DDD</h1>
  <ul>
    <li>ğŸ“š Ubiquitous Language (langage omniprÃ©sent)</li>
    <li>ğŸ“¦ Bounded Context</li>
    <li>ğŸ›ï¸ Entities et Value Objects</li>
    <li>ğŸ“ Aggregates</li>
    <li>ğŸ” Domain Events</li>
    <li>ğŸ§° Repositories, Factories, Services</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Chacun de ces concepts sera dÃ©taillÃ© dans les slides suivantes.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>ModÃ©lisation stratÃ©gique</h1>
  <p>Permet de comprendre les relations entre sous-domaines et les interactions entre contextes.</p>
  <ul>
    <li>DÃ©finir les <strong>Bounded Contexts</strong></li>
    <li>ModÃ©liser une <strong>Context Map</strong></li>
    <li>Identifier les <strong>relations entre Ã©quipes</strong> (Partnership, Shared Kernel...)</li>
  </ul>
  <img src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*CIbJ3VRJb0wxIYchS9PduA.png" alt="Context Map Example" style="width:80%">
  <aside class="notes">
    <ul>
      <li>Montrer quâ€™un contexte bornÃ© contient son propre modÃ¨le et langage. La context map est essentielle Ã  lâ€™alignement entre domaines.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>ModÃ©lisation tactique</h1>
  <p>DÃ©finir comment reprÃ©senter les objets du domaine dans le code.</p>
  <ul>
    <li>EntitÃ©s (IdentitÃ©)</li>
    <li>Value Objects (Immuables)</li>
    <li>Aggregats (CohÃ©rence transactionnelle)</li>
    <li>Domain Services (opÃ©rations mÃ©tier sans racine d'entitÃ©)</li>
    <li>Repositories (abstraction de persistance)</li>
  </ul>
  <img src="https://www.codingthearchitecture.com/assets/images/ddd-building-blocks.png" alt="DDD building blocks" style="width:70%">
  <aside class="notes">
    <ul>
      <li>Important de montrer que lâ€™implÃ©mentation suit le modÃ¨le mÃ©tier. Bien distinguer entitÃ©s et value objects.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Exemple : e-Commerce simplifiÃ©</h1>
  <ul>
    <li>ğŸ¯ Contexte : vente de produits en ligne</li>
    <li>ğŸ“¦ EntitÃ© : Commande</li>
    <li>ğŸ·ï¸ Value Object : Adresse</li>
    <li>ğŸ§¾ Service de domaine : Calcul de la remise</li>
    <li>ğŸ’½ Repository : CommandeRepository</li>
  </ul>
  <img src="https://raw.githubusercontent.com/ddd-crew/ddd-starter-modelling-process/main/images/ddd-aggregates.png" alt="DDD Aggregate Diagram" style="width:70%">
  <aside class="notes">
    <ul>
      <li>Utiliser un exemple simple pour fixer les concepts. Chaque composant reprÃ©sente une responsabilitÃ© mÃ©tier claire.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Conclusion & ouverture</h1>
  <ul>
    <li>âœ… DDD : mÃ©thode efficace pour modÃ©liser les systÃ¨mes complexes</li>
    <li>ğŸ§  NÃ©cessite collaboration Ã©troite mÃ©tier-technique</li>
    <li>ğŸ“ˆ Apporte de la robustesse dans les architectures distribuÃ©es</li>
    <li>ğŸšª Vers CQRS, Event Sourcing, Hexagonal Architecture</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Mettre en avant la valeur ajoutÃ©e du DDD dans les microservices. Mentionner les approches complÃ©mentaires.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Ressources & RÃ©fÃ©rences</h1>
  <ul>
    <li><a href="https://www.domainlanguage.com/ddd/">domainlanguage.com/ddd</a></li>
    <li><a href="https://www.dddcommunity.org">dddcommunity.org</a></li>
    <li><a href="https://github.com/ddd-crew">github.com/ddd-crew</a></li>
    <li><a href="https://martinfowler.com/bliki/BoundedContext.html">martinfowler.com - Bounded Context</a></li>
    <li><a href="https://www.youtube.com/watch?v=pMuiVlnGqjk" target="_blank">ğŸ“º InfoQ - DDD in Practice (Vaughn Vernon)</a></li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Inviter les Ã©tudiants Ã  explorer les communautÃ©s et projets open source (ddd-crew par exemple).</li>
    </ul>
  </aside>
</section>


<section>
  <h1>Quiz Final</h1>
  <ul>
    <li>ğŸ§  Qu'est-ce qu'un Bounded Context ?</li>
    <li>ğŸ“¦ Quelle est la diffÃ©rence entre une Entity et un Value Object ?</li>
    <li>ğŸ§¾ Pourquoi le langage omniprÃ©sent est-il central dans DDD ?</li>
    <li>ğŸ“ Quel est le rÃ´le dâ€™un agrÃ©gat ?</li>
    <li>ğŸŒ Ã€ quoi sert une context map ?</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Utiliser ces questions pour une auto-Ã©valuation ou un QCM interactif en fin de session.</li>
      <li>RÃ©ponses :
        <ul>
          <li>Bounded Context : Limite explicite dans laquelle un modÃ¨le est valide et cohÃ©rent.</li>
          <li>Entity vs Value Object : Une entitÃ© a une identitÃ© persistante, un VO est dÃ©fini par ses attributs.</li>
          <li>Langage omniprÃ©sent : Permet une communication claire entre technique et mÃ©tier.</li>
          <li>AgrÃ©gat : Regroupe des entitÃ©s/VO, garantit la cohÃ©rence des invariants mÃ©tier.</li>
          <li>Context Map : ReprÃ©sente les relations entre bounded contexts dans une organisation.</li>
        </ul>
      </li>
    </ul>
  </aside>
</section>
<section>
  <h1>Exemple de code : EntitÃ© Commande (TypeScript)</h1>
  <pre><code class="language-ts">class Adresse {
  constructor(
    public readonly rue: string,
    public readonly ville: string,
    public readonly codePostal: string
  ) {}
}

class Commande {
  private status: 'EN_ATTENTE' | 'PAYEE';
  private date: Date;

  constructor(
    public readonly id: string,
    public readonly client: string,
    public readonly adresseLivraison: Adresse,
    public readonly lignes: string[]
  ) {
    this.date = new Date();
    this.status = 'EN_ATTENTE';
  }

  validerPaiement(): void {
    this.status = 'PAYEE';
    console.log(`Paiement validÃ© pour la commande ${this.id}`);
  }
}</code></pre>
  <aside class="notes">
    <ul>
      <li>Utilisation de TypeScript pour expliciter les types. Lâ€™adresse est un Value Object. Commande est une entitÃ© avec logique mÃ©tier.</li>
    </ul>
  </aside>
</section>
<section>
  <h1>Live Coding : Objectif</h1>
  <ul>
    <li>Montrer comment un service d'application encapsule la logique mÃ©tier</li>
    <li>CrÃ©er une commande Ã  partir d'un DTO</li>
    <li>Isoler la logique de persistance avec un repository</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Cette dÃ©mo vise Ã  illustrer comment appliquer concrÃ¨tement DDD dans un service typÃ© et testable.</li>
    </ul>
  </aside>
</section>
<section>
  <h1>Live Coding : Service de Commande (TypeScript)</h1>
  <pre><code class="language-ts">interface CommandeRepository {
  save(commande: Commande): void;
}

class CommandeService {
  constructor(private repository: CommandeRepository) {}

  creerCommande(dto: {
    id: string;
    client: string;
    rue: string;
    ville: string;
    codePostal: string;
    lignes: string[];
  }): Commande {
    const adresse = new Adresse(dto.rue, dto.ville, dto.codePostal);
    const commande = new Commande(dto.id, dto.client, adresse, dto.lignes);
    this.repository.save(commande);
    return commande;
  }
}

// Exemple d'utilisation
const fakeRepo: CommandeRepository = {
  save: (c) => console.log('âœ… SauvegardÃ©e :', c)
};

const service = new CommandeService(fakeRepo);
service.creerCommande({
  id: 'CMD001',
  client: 'Client123',
  rue: '10 rue des Lilas',
  ville: 'Paris',
  codePostal: '75000',
  lignes: ['ProduitA', 'ProduitB']
});</code></pre>
  <aside class="notes">
    <ul>
      <li>Le service applique la logique mÃ©tier sans se soucier de la persistance rÃ©elle. Typage explicite pour la clartÃ©.</li>
    </ul>
  </aside>
</section>
