<section>
  <h1>Domain Driven Design (DDD)</h1>
  <p>Introduction au Domain Driven Design dans le cadre de la conception d'applications distribuées.</p>
  <aside class="notes">
    <ul>
      <li>Introduction du sujet. DDD permet de mieux aligner la technique avec les besoins métier.</li>
    </ul>
  </aside>
</section>
<section>
  <h1>Sommaire</h1>
  <ul>
    <li>Pourquoi DDD ?</li>
    <li>Concepts fondamentaux</li>
    <li>Structure d'un projet DDD</li>
    <li>Modélisation stratégique</li>
    <li>Modélisation tactique</li>
    <li>Exemples concrets</li>
    <li>Conclusion et ouverture</li>
    <li>Ressources & Références</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Présenter le plan. Expliquer la différence entre la modélisation stratégique (vue d'ensemble) et tactique (implémentation).</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Pourquoi Domain Driven Design ?</h1>
  <p>Le DDD permet d’adresser la complexité des domaines métiers avec une architecture logicielle centrée sur le métier.</p>
  <ul>
    <li>Aligner technique et métier</li>
    <li>Faciliter la communication</li>
    <li>Réduire la dette technique</li>
    <li>Gérer la complexité des systèmes distribués</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Insister sur l'importance du langage commun et du découpage par responsabilité métier dans les systèmes complexes.</li>
    </ul>
  </aside>
</section>
<section>
  <h1>Pourquoi Domain-Driven Design ?</h1>
  <p>Un ensemble de pratiques pour aligner le logiciel sur le cœur métier et maîtriser la complexité.</p>
  <ul>
    <li>🧩 Gérer la complexité des domaines riches</li>
    <li>🤝 Améliorer la collaboration métier–technique</li>
    <li>⚙️ Réduire la dette technique et le couplage involontaire</li>
    <li>🌐 Faciliter la cohérence dans les architectures distribuées</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Insister sur les enjeux des systèmes distribués : multiples équipes, microservices, transactions partielles.</li>
      <li>Expliquer comment un langage commun (Ubiquitous Language) évite les malentendus entre développeurs et experts métier.</li>
      <li>Montrer qu’un bon découpage en bounded contexts limite la propagation des changements et favorise l’autonomie des équipes.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Ubiquitous Language</h1>
  <p>Le vocabulaire partagé et rigoureux utilisé dans tout le projet, du code aux réunions.</p>
  <ul>
    <li>📖 Décrit précisément les concepts métier</li>
    <li>🔄 Utilisé dans les tests, la documentation et le code</li>
    <li>🤓 Évolue avec le domaine et s’adapte aux retours métier</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Donner l’exemple d’un “Order ” vs “Purchase ”: mêmes mots, sens différents selon le contexte.</li>
      <li>Montrer comment les reviewers de PR vérifient la cohérence du langage omniprésent.</li>
      <li>Avantage : détecter tôt les mauvaises compréhensions avant qu’elles n’atterrissent en prod.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Bounded Context</h1>
  <p>Frontière explicite dans laquelle un modèle et un langage sont cohérents.</p>
  <ul>
    <li>↕️ Modèle et langage propres</li>
    <li>🔗 Interaction via des API/formats convenus</li>
    <li>📦 Context Map documente les relations</li>
  </ul>
  <img src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*CIbJ3VRJb0wxIYchS9PduA.png" alt="Context Map Example" style="width:75%">
  <aside class="notes">
    <ul>
      <li>Présenter les patterns de relation :  
        <ul>
          <li><strong>Partnership</strong> : deux équipes coopèrent étroitement.</li>
          <li><strong>Shared Kernel</strong> : partage d’un sous-modèle commun.</li>
          <li><strong>Customer–Supplier</strong> : un contexte proveedor dicte le contrat.</li>
          <li><strong>Conformist</strong> : on s’aligne sur le modèle d’un fournisseur sans négociation.</li>
          <li><strong>Anti-Corruption Layer</strong> : adapter/transformer pour éviter la « pollution » d’un modèle externe.</li>
        </ul>
      </li>
      <li>Expliquer l’importance de choisir le bon pattern selon le découpage organisationnel.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Entités (Entities)</h1>
  <p>Objets définis par leur identité, ayant un cycle de vie et des invariants.</p>
  <ul>
    <li>🆔 Identité unique (ID immuable)</li>
    <li>⏳ Cycle de vie (création, évolution, suppression)</li>
    <li>🔒 Invariants métier (règles toujours vraies)</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Exemple : <em>Commande</em> avec son ID et son statut ; même contenu, deux commandes diffèrent.</li>
      <li>Invariants : date de livraison ≥ date de commande, montant total ≥ 0.</li>
      <li>Montrer un diagramme UML d’une entité simple avec attributs et méthodes métier.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Value Objects</h1>
  <p>Objets définis par leurs attributs, immuables et sans identité propre.</p>
  <ul>
    <li>🎨 Égalité par valeur (equals)</li>
    <li>🔒 Immuables pour garantir la cohérence</li>
    <li>📦 Encapsulent des concepts (p.ex. Adresse, Money)</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Exemple : adresse de livraison. Deux adresses avec mêmes champs sont interchangeables.</li>
      <li>Eviter les setters ; recréer l’objet pour « modifier » une valeur.</li>
      <li>Avantage performance : caches, partages d’instances identiques.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Agrégats (Aggregates)</h1>
  <p>Regroupent des entités et des value objects autour d’une racine (Aggregate Root).</p>
  <ul>
    <li>🌳 Racine unique contrôlant l’accès externe</li>
    <li>🔗 Garantissent les invariants transactionnels</li>
    <li>🛡️ Limite de consistance : pas de référence directe hors agrégat</li>
  </ul>
  <img src="https://raw.githubusercontent.com/ddd-crew/ddd-starter-modelling-process/main/images/ddd-aggregates.png" alt="Aggregates Diagram" style="width:70%">
  <aside class="notes">
    <ul>
      <li>Montrer comment la racine coordonne la création et les règles (p.ex. ajout de ligne de commande).</li>
      <li>Expliquer la notion de « Transactional Boundary » : tout dans l’agrégat est atomique.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Domain Services & Factories & Repositories</h1>
  <p>Composants supports ne tenant pas directement d’état à long terme.</p>
  <ul>
    <li>⚙️ <strong>Domain Service</strong> : opérations métier sans entité propriétaire</li>
    <li>🏭 <strong>Factory</strong> : encapsule la création complexe d’objets</li>
    <li>💾 <strong>Repository</strong> : interface entre le domaine et la persistance</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Domain Service : calcul de remise globale, orchestration de plusieurs agrégats.</li>
      <li>Factory : création d’un agrégat avec ID, champs calculés, règles de construction.</li>
      <li>Repository : expose save(), findById(), findBySpec() ; respecte l’Interface Segregation.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Domain Events</h1>
  <p>Événements immuables déclenchés lors de changements significatifs du domaine.</p>
  <ul>
    <li>📣 Notifier d’autres contextes ou sous-domaines</li>
    <li>⏱️ Souvent utilisés pour l’asynchronisme et l’évolutivité</li>
    <li>🔄 Favorisent la consistance éventuelle</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Exemple : “OrderPaid” publié après validation du paiement.</li>
      <li>Patron Pub/Sub : les autres bounded contexts réagissent pour déclencher des workflows.</li>
      <li>Attention à la duplication de données et à l’ordonnancement.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Modélisation stratégique détaillée</h1>
  <p>Définir le paysage global avant d’entrer dans le détail tactique.</p>
  <ul>
    <li>📍 Identification des sous-domaines (core, supporting, generic)</li>
    <li>🗺️ Dessiner la Context Map et choisir les patterns</li>
    <li>🤼‍♂️ Organiser les équipes par contextes indépendants</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Core Domain : cœur de la différenciation métier, mérite les ressources clés.</li>
      <li>Supporting Domain : second rôle, souvent externalisable.</li>
      <li>Generic Domain : fonctions transversales (ex. authentification), préférez une solution “off-the-shelf”.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Modélisation tactique détaillée</h1>
  <p>Appliquer les building blocks DDD dans la couche code.</p>
  <ul>
    <li>Identifier les entités vs VO</li>
    <li>Définir les agrégats et frontières transactionnelles</li>
    <li>Encapsuler la logique métier dans services/domain events</li>
    <li>Isoler la persistance via repositories/factories</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Montrer un extrait de code TypeScript pour chaque building block.</li>
      <li>Expliquer le test unitaire par agrégat en simulant les invariants.</li>
      <li>Illustrer l’injection de dépendances pour factories et repositories.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Concepts fondamentaux du DDD</h1>
  <ul>
    <li>📚 Ubiquitous Language (langage omniprésent)</li>
    <li>📦 Bounded Context</li>
    <li>🏛️ Entities et Value Objects</li>
    <li>📐 Aggregates</li>
    <li>🔁 Domain Events</li>
    <li>🧰 Repositories, Factories, Services</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Chacun de ces concepts sera détaillé dans les slides suivantes.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Modélisation stratégique</h1>
  <p>Permet de comprendre les relations entre sous-domaines et les interactions entre contextes.</p>
  <ul>
    <li>Définir les <strong>Bounded Contexts</strong></li>
    <li>Modéliser une <strong>Context Map</strong></li>
    <li>Identifier les <strong>relations entre équipes</strong> (Partnership, Shared Kernel...)</li>
  </ul>
  <img src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*CIbJ3VRJb0wxIYchS9PduA.png" alt="Context Map Example" style="width:80%">
  <aside class="notes">
    <ul>
      <li>Montrer qu’un contexte borné contient son propre modèle et langage. La context map est essentielle à l’alignement entre domaines.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Modélisation tactique</h1>
  <p>Définir comment représenter les objets du domaine dans le code.</p>
  <ul>
    <li>Entités (Identité)</li>
    <li>Value Objects (Immuables)</li>
    <li>Aggregats (Cohérence transactionnelle)</li>
    <li>Domain Services (opérations métier sans racine d'entité)</li>
    <li>Repositories (abstraction de persistance)</li>
  </ul>
  <img src="https://www.codingthearchitecture.com/assets/images/ddd-building-blocks.png" alt="DDD building blocks" style="width:70%">
  <aside class="notes">
    <ul>
      <li>Important de montrer que l’implémentation suit le modèle métier. Bien distinguer entités et value objects.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Exemple : e-Commerce simplifié</h1>
  <ul>
    <li>🎯 Contexte : vente de produits en ligne</li>
    <li>📦 Entité : Commande</li>
    <li>🏷️ Value Object : Adresse</li>
    <li>🧾 Service de domaine : Calcul de la remise</li>
    <li>💽 Repository : CommandeRepository</li>
  </ul>
  <img src="https://raw.githubusercontent.com/ddd-crew/ddd-starter-modelling-process/main/images/ddd-aggregates.png" alt="DDD Aggregate Diagram" style="width:70%">
  <aside class="notes">
    <ul>
      <li>Utiliser un exemple simple pour fixer les concepts. Chaque composant représente une responsabilité métier claire.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Conclusion & ouverture</h1>
  <ul>
    <li>✅ DDD : méthode efficace pour modéliser les systèmes complexes</li>
    <li>🧠 Nécessite collaboration étroite métier-technique</li>
    <li>📈 Apporte de la robustesse dans les architectures distribuées</li>
    <li>🚪 Vers CQRS, Event Sourcing, Hexagonal Architecture</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Mettre en avant la valeur ajoutée du DDD dans les microservices. Mentionner les approches complémentaires.</li>
    </ul>
  </aside>
</section>

<section>
  <h1>Ressources & Références</h1>
  <ul>
    <li><a href="https://www.domainlanguage.com/ddd/">domainlanguage.com/ddd</a></li>
    <li><a href="https://www.dddcommunity.org">dddcommunity.org</a></li>
    <li><a href="https://github.com/ddd-crew">github.com/ddd-crew</a></li>
    <li><a href="https://martinfowler.com/bliki/BoundedContext.html">martinfowler.com - Bounded Context</a></li>
    <li><a href="https://www.youtube.com/watch?v=pMuiVlnGqjk" target="_blank">📺 InfoQ - DDD in Practice (Vaughn Vernon)</a></li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Inviter les étudiants à explorer les communautés et projets open source (ddd-crew par exemple).</li>
    </ul>
  </aside>
</section>


<section>
  <h1>Quiz Final</h1>
  <ul>
    <li>🧠 Qu'est-ce qu'un Bounded Context ?</li>
    <li>📦 Quelle est la différence entre une Entity et un Value Object ?</li>
    <li>🧾 Pourquoi le langage omniprésent est-il central dans DDD ?</li>
    <li>📐 Quel est le rôle d’un agrégat ?</li>
    <li>🌍 À quoi sert une context map ?</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Utiliser ces questions pour une auto-évaluation ou un QCM interactif en fin de session.</li>
      <li>Réponses :
        <ul>
          <li>Bounded Context : Limite explicite dans laquelle un modèle est valide et cohérent.</li>
          <li>Entity vs Value Object : Une entité a une identité persistante, un VO est défini par ses attributs.</li>
          <li>Langage omniprésent : Permet une communication claire entre technique et métier.</li>
          <li>Agrégat : Regroupe des entités/VO, garantit la cohérence des invariants métier.</li>
          <li>Context Map : Représente les relations entre bounded contexts dans une organisation.</li>
        </ul>
      </li>
    </ul>
  </aside>
</section>
<section>
  <h1>Exemple de code : Entité Commande (TypeScript)</h1>
  <pre><code class="language-ts">class Adresse {
  constructor(
    public readonly rue: string,
    public readonly ville: string,
    public readonly codePostal: string
  ) {}
}

class Commande {
  private status: 'EN_ATTENTE' | 'PAYEE';
  private date: Date;

  constructor(
    public readonly id: string,
    public readonly client: string,
    public readonly adresseLivraison: Adresse,
    public readonly lignes: string[]
  ) {
    this.date = new Date();
    this.status = 'EN_ATTENTE';
  }

  validerPaiement(): void {
    this.status = 'PAYEE';
    console.log(`Paiement validé pour la commande ${this.id}`);
  }
}</code></pre>
  <aside class="notes">
    <ul>
      <li>Utilisation de TypeScript pour expliciter les types. L’adresse est un Value Object. Commande est une entité avec logique métier.</li>
    </ul>
  </aside>
</section>
<section>
  <h1>Live Coding : Objectif</h1>
  <ul>
    <li>Montrer comment un service d'application encapsule la logique métier</li>
    <li>Créer une commande à partir d'un DTO</li>
    <li>Isoler la logique de persistance avec un repository</li>
  </ul>
  <aside class="notes">
    <ul>
      <li>Cette démo vise à illustrer comment appliquer concrètement DDD dans un service typé et testable.</li>
    </ul>
  </aside>
</section>
<section>
  <h1>Live Coding : Service de Commande (TypeScript)</h1>
  <pre><code class="language-ts">interface CommandeRepository {
  save(commande: Commande): void;
}

class CommandeService {
  constructor(private repository: CommandeRepository) {}

  creerCommande(dto: {
    id: string;
    client: string;
    rue: string;
    ville: string;
    codePostal: string;
    lignes: string[];
  }): Commande {
    const adresse = new Adresse(dto.rue, dto.ville, dto.codePostal);
    const commande = new Commande(dto.id, dto.client, adresse, dto.lignes);
    this.repository.save(commande);
    return commande;
  }
}

// Exemple d'utilisation
const fakeRepo: CommandeRepository = {
  save: (c) => console.log('✅ Sauvegardée :', c)
};

const service = new CommandeService(fakeRepo);
service.creerCommande({
  id: 'CMD001',
  client: 'Client123',
  rue: '10 rue des Lilas',
  ville: 'Paris',
  codePostal: '75000',
  lignes: ['ProduitA', 'ProduitB']
});</code></pre>
  <aside class="notes">
    <ul>
      <li>Le service applique la logique métier sans se soucier de la persistance réelle. Typage explicite pour la clarté.</li>
    </ul>
  </aside>
</section>
