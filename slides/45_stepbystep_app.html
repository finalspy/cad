<section>
  <h2>Travaux Pratiques : Refactorisation & Industrialisation Node.js</h2>
  <ul>
    <li>S√©curiser, tester, r√©organiser, typiser et pr√©parer le code √† la modularisation</li>
    <li>Application support : gestion de pr√©sentations en Node.js (MVC)</li>
    <li>Travail progressif, exemples concrets, code AVANT/APR√àS et sch√©mas</li>
  </ul>
  <aside class="notes">
    Ce TP vous guide pour moderniser une appli Node.js en suivant les meilleures pratiques du march√©, de la mise en place des tests √† l'architecture hexagonale.
  </aside>
</section>

<!-- TABLE DES MATI√àRES -->
<section>
  <h3>Sommaire</h3>
  <ul>
    <li>1. Ajouter/compl√©ter les tests</li>
    <li>2. Automatiser les tests avec GitHub Actions</li>
    <li>3. R√©duire le couplage entre modules</li>
    <li>4. Migration TypeScript</li>
    <li>5. R√©organiser la structure du projet (hexagonal)</li>
    <li>6. Impl√©menter Ports & Adapters (Hexagonal)</li>
    <li>Conclusion & bonnes pratiques</li>
    <li>Pour aller plus loin</li>
  </ul>
</section>

<!-- STRUCTURE INITIALE -->
<section>
  <h3>Structure initiale du projet</h3>
  <pre><code>
src/
  services/
  routes/
  controllers/
  utils/
  middleware/
  models/
  tests/
  ...
views/
  ...
  </code></pre>
  <aside class="notes">
    Structure typique Express MVC. L'objectif est de la rendre plus maintenable, test√©e et pr√™te pour l'extension.
  </aside>
</section>

<section>
  <h3>Objectifs de la refonte</h3>
  <ul>
    <li>Assurer la non-r√©gression avec des tests robustes</li>
    <li>Standardiser la qualit√© via CI/CD</li>
    <li>R√©duire le couplage et augmenter la modularit√©</li>
    <li>Adopter TypeScript et un design Domain-Driven</li>
    <li>Pr√©parer la future migration vers les microservices</li>
  </ul>
  <aside class="notes">
    La d√©marche vise la fiabilit√©, la clart√© du code, et la p√©rennit√© de l'application.
  </aside>
</section>

<!-- ETAPE 1 : TESTS -->
<section>
  <h3>1. Ajouter/compl√©ter les tests</h3>
  <ul>
    <li>Lister et ex√©cuter les tests existants</li>
    <li>Ajouter les tests manquants (unitaires, int√©gration, HTTP)</li>
    <li>G√©n√©rer un rapport de couverture</li>
    <li>Documenter et taguer les tests legacy</li>
  </ul>
  <aside class="notes">
    Avant toute refonte, s√©curiser le code pour d√©tecter d'√©ventuelles r√©gressions. On vise une couverture de 80 % minimum.
  </aside>
</section>

<section>
  <h3>√âtapes pratiques pour les tests</h3>
  <ul>
    <li><b>1. Identifier :</b> Quels fichiers/services/controllers ne sont pas test√©s ?</li>
    <li><b>2. Ajouter :</b> Pour chaque ‚Äútrou‚Äù, √©crire un test pertinent.</li>
    <li><b>3. Ex√©cuter :</b> <code>npm test</code> puis <code>npm run coverage</code></li>
    <li><b>4. Documenter :</b> Les cas legacy ou tests instables.</li>
  </ul>
  <aside class="notes">
    Utilisez la couverture g√©n√©r√©e (HTML, lcov) pour rep√©rer rapidement les fichiers oubli√©s. Documenter dans un fichier TESTPLAN.md les cas d'usage, les legacy et les limites connues.
  </aside>
</section>

<!-- AVANT/APRES AJOUT D'UN TEST MANQUANT -->
<section>
  <h3>Exemple : test manquant sur userController</h3>
  <p><b>Avant (userController.test.js) :</b></p>
  <pre><code>
  describe("getUser", () => {
    it("renvoie 200 et l'utilisateur existant", async () => {
    // ... test existant pour le cas succ√®s
  });
  // üö© Il manque le test pour l'utilisateur inconnu (404)
});
  </code></pre>
  <aside class="notes">
    Ce fichier ne teste que le cas o√π l'utilisateur existe. Il faut ajouter les cas 404 et erreur serveur.
  </aside>
</section>

<section>
  <h3>Apr√®s : test ajout√© (userController.test.js)</h3>
  <pre><code>
  describe("getUser", () => {
    it("renvoie 200 et l'utilisateur existant", async () => {
    // ... (test existant)
  });

  it("renvoie 404 si l'utilisateur n'existe pas", async () => {
    req.params.id = "u2";
    vi.spyOn(User, "findById").mockResolvedValue(null);

    await userController.getUser(req, res);

    expect(User.findById).toHaveBeenCalledWith("u2");
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({ message: "User not found" });
  });
});
  </code></pre>
  <aside class="notes">
    Ce test garantit que si l'utilisateur est absent, la route retourne bien un 404. Ajoutez syst√©matiquement les cas d'erreur pour chaque endpoint/service critique.
  </aside>
</section>

<section>
  <h3>G√©n√©rer et analyser la couverture</h3>
  <ul>
    <li>Lancez <code>npm run coverage</code> (ou <code>vitest run --coverage</code>)</li>
    <li>Fixez un seuil minimal (ex : 80%) dans votre CI</li>
    <li>Rep√©rez les ‚Äúzones rouges‚Äù pour les compl√©ter</li>
  </ul>
  <aside class="notes">
    Ajoutez la commande dans le package.json si elle n'existe pas. V√©rifiez le rapport HTML et priorisez les fichiers les moins couverts.
  </aside>
</section>

<!-- ETAPE 2 : CI/CD -->
<section>
  <h3>2. Automatiser les tests avec GitHub Actions</h3>
  <ul>
    <li>Cr√©er <code>.github/workflows/ci.yml</code></li>
    <li>Ajouter les jobs pour lint, test et coverage</li>
    <li>Afficher un badge ‚Äúbuild passing‚Äù dans le README</li>
    <li>Prot√©ger la branche main (GitHub settings)</li>
  </ul>
  <pre><code>
name: Node.js CI

on: [push, pull_request]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      - run: npm ci
      - run: npm run lint
      - run: npm test
      - run: npm run coverage -- --coverage
  </code></pre>
  <aside class="notes">
    Le pipeline CI assure que tout commit/PR passe la barre des tests. Ajoutez des jobs pour coverage, lint, et badge README pour la transparence.
  </aside>
</section>

<section>
  <h3>Exemple : badge ‚Äúbuild passing‚Äù</h3>
  <pre><code>
<!-- Dans le README.md -->
![CI](https://github.com/&lt;utilisateur&gt;/&lt;repo&gt;/actions/workflows/ci.yml/badge.svg)
  </code></pre>
  <aside class="notes">
    Ce badge s'affiche en t√™te du README, signalant l'√©tat du dernier build GitHub Actions. V√©rifiez que le badge passe bien au vert apr√®s chaque push.
  </aside>
</section>

<!-- ETAPE 3 : COUPLAGE -->
<section>
  <h3>3. R√©duire le couplage entre modules</h3>
  <ul>
    <li>Rep√©rer les d√©pendances cycliques et les ‚Äúgod objects‚Äù</li>
    <li>Introduire des interfaces pour les points critiques</li>
    <li>D√©coupler contr√¥leurs/services via injection de d√©pendances</li>
    <li>Mettre √† jour les tests avec des mocks/stubs</li>
  </ul>
  <aside class="notes">
    Objectif : chaque composant doit pouvoir √™tre test√©/migr√© isol√©ment. Pr√©f√©rez des d√©pendances pass√©es en param√®tre plut√¥t qu'import√©es en dur.
  </aside>
</section>

<section>
  <h3>Exemple AVANT : couplage fort</h3>
  <pre><code>
// controllers/userController.js
const UserService = require('../services/userService');

exports.getUser = async (req, res) => {
  const user = await UserService.getUserById(req.params.id);
  // ...
};
  </code></pre>
  <aside class="notes">
    Ici, le contr√¥leur importe directement l'impl√©mentation concr√®te. Difficile √† tester ou remplacer !
  </aside>
</section>

<section>
  <h3>Apr√®s : d√©couplage via interface/service inject√©</h3>
  <pre><code>
// controllers/userController.js
exports.createUserController = (userService) => ({
  getUser: async (req, res) => {
    const user = await userService.getUserById(req.params.id);
    // ...
  }
});

// server.js/app.js
const { createUserController } = require('./controllers/userController');
const userController = createUserController(UserService);
  </code></pre>
  <aside class="notes">
    Le contr√¥leur devient ind√©pendant : on injecte le service au lieu de l'importer. Les tests peuvent passer un fake/mock service.
  </aside>
</section>

<!-- ETAPE 4 : TYPESCRIPT -->
<section>
  <h3>4. Migration TypeScript</h3>
  <ul>
    <li>Ajouter <code>tsconfig.json</code> strict</li>
    <li>Renommer les fichiers .js en .ts (progressivement)</li>
    <li>Ajouter les types pour fonctions, objets, retours</li>
    <li>Corriger les erreurs, ajuster les tests</li>
    <li>Adapter la config Vitest/Jest (ts-jest, etc.)</li>
  </ul>
  <aside class="notes">
    Le typage explicite d√©tecte plus d'erreurs √† la compilation, limite les bugs et rend la base plus robuste.
  </aside>
</section>

<section>
  <h3>Exemple AVANT : JavaScript ‚Äúlibre‚Äù</h3>
  <pre><code>
// models/user.js
const mongoose = require('mongoose');
const UserSchema = new mongoose.Schema({
  username: String,
  email: String
});
module.exports = mongoose.model('User', UserSchema);
  </code></pre>
  <aside class="notes">
    Aucun type n'est v√©rifi√©, le moindre oubli ou changement de structure peut passer inaper√ßu.
  </aside>
</section>

<section>
  <h3>Apr√®s : passage TypeScript</h3>
  <pre><code>
// models/user.ts
import { Schema, model, Document } from 'mongoose';

export interface User extends Document {
  username: string;
  email: string;
}

const UserSchema = new Schema<User>({
  username: { type: String, required: true },
  email: { type: String, required: true }
});

export default model<User>('User', UserSchema);
  </code></pre>
  <aside class="notes">
    L'interface User permet d'attraper les fautes de frappe ou d'oublis de champs √† la compilation.
  </aside>
</section>

<!-- ETAPE 5 : REORGANISATION EN COUCHES -->
<section>
  <h3>5. R√©organiser la structure du projet (hexagonal)</h3>
  <ul>
    <li>Cr√©er les dossiers <b>domain/</b>, <b>application/</b>, <b>infrastructure/</b>, <b>interfaces/</b></li>
    <li>D√©placer entit√©s, use cases, adaptateurs techniques dans les bons dossiers</li>
    <li>Mettre √† jour tous les imports relatifs</li>
    <li>Documenter la nouvelle architecture</li>
    <li>Refactorer progressivement (PR par feature)</li>
  </ul>
  <aside class="notes">
    On passe d'un MVC ‚Äúfourre-tout‚Äù √† une s√©paration claire Domain/Infra/Application, qui permet de mieux tester, remplacer et √©tendre l'application.
  </aside>
</section>

<section>
  <h3>Sch√©ma AVANT / APR√àS</h3>
  <ul>
    <li>Avant :<br>
      <pre>
src/
  controllers/
  models/
  services/
  ...
      </pre>
    </li>
    <li>Apr√®s :<br>
      <pre>
src/
  domain/
    entities/
    valueObjects/
    ports/
  application/
    usecases/
    services/
  infrastructure/
    orm/
    externalApis/
    repositories/
  interfaces/
    http/
    cli/
      </pre>
    </li>
  </ul>
  <aside class="notes">
    On distingue clairement la logique m√©tier (domain), l'orchestration m√©tier (application), la technique (infrastructure), et les points d'entr√©e (interfaces).
  </aside>
</section>

<section>
  <h3>Exemple pratique de d√©placement</h3>
  <ul>
    <li><code>models/user.ts</code> ‚Üí <code>domain/entities/User.ts</code></li>
    <li><code>services/authService.ts</code> ‚Üí <code>application/services/AuthService.ts</code></li>
    <li><code>controllers/userController.ts</code> ‚Üí <code>interfaces/http/UserController.ts</code></li>
    <li><code>models/user.js</code> (impl√© Mongo) ‚Üí <code>infrastructure/orm/MongoUserRepository.ts</code></li>
  </ul>
  <aside class="notes">
    Pour chaque fichier, demandez-vous : ce code rel√®ve-t-il du m√©tier (domain), de l'orchestration m√©tier (application), de la technique (infra) ou de l'IHM (interfaces) ?
  </aside>
</section>

<!-- ETAPE 6 : HEXAGONALE -->
<section>
  <h3>6. Impl√©menter Ports & Adapters (Hexagonal)</h3>
  <ul>
    <li>Cr√©er des <b>ports</b> (interfaces m√©tier) dans <code>domain/ports/</code></li>
    <li>Impl√©menter des <b>adapters</b> dans <code>infrastructure/</code></li>
    <li>Injecter les d√©pendances (par constructeur, DI, factory‚Ä¶)</li>
    <li>Toutes les entr√©es passent par l'application & le domaine</li>
    <li>Tester le m√©tier avec des mocks/fakes</li>
  </ul>
  <aside class="notes">
    Les ports d√©finissent ‚Äúce dont le m√©tier a besoin‚Äù. Les adapters branchent la technique r√©elle (Mongo, SendGrid‚Ä¶) sans polluer la logique m√©tier.
  </aside>
</section>

<section>
  <h3>Sch√©ma : Architecture hexagonale</h3>
  <pre><code>
+----------------------+ 
| Interfaces (API)     | 
+----------+-----------+ 
           | 
+----------v-----------+ 
| Application          | 
+----------+-----------+ 
           | 
+----------v-----------+ 
| Domaine (M√©tier)     | 
+----------+-----------+ 
           | 
+----------v-----------+ 
| Ports (Interfaces)   | 
+----------+-----------+ 
           | 
+----------v-----------+ 
| Adapters Techniques  | 
+----------------------+
  </code></pre>
  <aside class="notes">
    Le m√©tier ne d√©pend plus du technique. On peut brancher une base, un mock, un API externe sans toucher au reste du code.
  </aside>
</section>

<section>
  <h3>Exemple : port + adapter</h3>
  <pre><code>
// domain/ports/UserRepository.ts
export interface UserRepository {
  findById(id: string): Promise&lt;User | null&gt;;
  save(user: User): Promise&lt;User&gt;;
}

// infrastructure/orm/MongoUserRepository.ts
import { UserRepository } from '../../domain/ports/UserRepository';
export class MongoUserRepository implements UserRepository {
  async findById(id) { /* ... */ }
  async save(user) { /* ... */ }
}
  </code></pre>
  <aside class="notes">
    Le code m√©tier ne conna√Æt que l'interface, jamais l'impl√©mentation technique. On ‚Äúbranche‚Äù la bonne impl√©mentation au d√©marrage de l'appli.
  </aside>
</section>

<section>
  <h3>Apr√®s : injection dans l'application</h3>
  <pre><code>
// application/usecases/GetUser.ts
export class GetUser {
  constructor(private userRepository: UserRepository) {}
  async execute(id: string) {
    return this.userRepository.findById(id);
  }
}

// interfaces/http/UserController.ts
const usecase = new GetUser(new MongoUserRepository());
app.get('/users/:id', async (req, res) => {
  const user = await usecase.execute(req.params.id);
  res.json(user);
});
  </code></pre>
  <aside class="notes">
    Pour tester GetUser, il suffit de passer un mock UserRepository. La route n'acc√®de plus ni √† Mongo, ni au m√©tier directement.
  </aside>
</section>

<section>
  <h3>Conclusion & bonnes pratiques</h3>
  <ul>
    <li>Commencez par s√©curiser la base avec des tests exhaustifs</li>
    <li>Industrialisez la CI/CD d√®s le d√©but</li>
    <li>D√©coupez et typisez le code pour gagner en robustesse</li>
    <li>Adoptez l'architecture hexagonale pour isoler le m√©tier</li>
    <li>Testez chaque couche ind√©pendamment (mocks, fakes‚Ä¶)</li>
    <li>It√©rez progressivement : refactoring √©tape par √©tape</li>
  </ul>
  <aside class="notes">
    Ce TP vous donne la feuille de route pour industrialiser tout projet Node.js : code plus robuste, √©quipe plus sereine, projet plus durable.
  </aside>
</section>

<section>
  <h3>Pour aller plus loin</h3>
  <ul>
    <li><a href="https://martinfowler.com/bliki/HexagonalArchitecture.html" target="_blank">Hexagonal Architecture (Martin Fowler)</a></li>
    <li><a href="https://khalilstemmler.com/articles/software-design-architecture/ddd-intro/" target="_blank">DDD par l'exemple</a></li>
    <li><a href="https://dev.to/domysee/hexagonal-architecture-in-nodejs-1efb" target="_blank">Hexagonal en Node.js</a></li>
    <li><a href="https://testingjavascript.com/" target="_blank">Testing JavaScript (Kent C. Dodds)</a></li>
  </ul>
  <aside class="notes">
    Explorez les sources, inspirez-vous pour aller plus loin dans la conception logicielle avanc√©e et la mise en pratique du DDD/hexagonal.
  </aside>
</section>